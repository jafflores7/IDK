import { z } from 'zod';
import express from 'express';
import cors from 'cors';
import helmet from 'helmet';
import rateLimit from 'express-rate-limit';
import { randomUUID, createHash } from 'crypto';
import { performance } from 'perf_hooks';

// Core type definitions for AI Spine tools
// Error types
class ToolError extends Error {
    code;
    details;
    constructor(message, code = 'TOOL_ERROR', details) {
        super(message);
        this.name = 'ToolError';
        this.code = code;
        this.details = details;
    }
}
class ValidationError extends ToolError {
    constructor(message, field, value) {
        super(message, 'VALIDATION_ERROR', { field, value });
        this.name = 'ValidationError';
    }
}
class ConfigurationError extends ToolError {
    constructor(message, missingKeys) {
        super(message, 'CONFIGURATION_ERROR', { missingKeys });
        this.name = 'ConfigurationError';
    }
}
class ExecutionError extends ToolError {
    constructor(message, cause) {
        super(message, 'EXECUTION_ERROR', { cause: cause?.message });
        this.name = 'ExecutionError';
    }
}

/**
 * Advanced validation system for AI Spine tools using Zod for robust schema validation.
 * This module provides comprehensive validation for tool inputs, configurations, and
 * cross-field relationships with performance optimizations and detailed error reporting.
 *
 * @example
 * ```typescript
 * import { ZodSchemaValidator } from '@ai-spine/tools-core';
 *
 * const validator = new ZodSchemaValidator();
 *
 * // Validate tool input
 *
 
 * const result = await validator.validateInput(inputData, inputSchema);
 * if (!result.success) {
 *   console.error('Validation errors:', result.errors);
 * }
 *
 * // Validate configuration
 * const configResult = await validator.validateConfig(config, configSchema);
 * ```
 */
/**
 * Advanced schema validator using Zod for robust validation with caching,
 * performance optimization, and detailed error reporting.
 */
class ZodSchemaValidator {
    static CACHE_TTL_MS = 5 * 60 * 1000; // 5 minutes
    static MAX_CACHE_SIZE = 1000;
    /** Schema cache for performance optimization */
    schemaCache = new Map();
    /** Performance metrics */
    metrics = {
        totalValidations: 0,
        cacheHits: 0,
        averageDurationMs: 0,
        totalDurationMs: 0,
    };
    /**
     * Validates tool input data against the provided schema
     */
    async validateInput(input, schema, _options = {}) {
        const startTime = Date.now();
        try {
            // Build Zod schema for input validation
            const zodSchema = this.buildInputSchema(schema, _options);
            // Perform validation
            const result = await this.performValidation(zodSchema, input, _options);
            const duration = Date.now() - startTime;
            this.updateMetrics(duration, result.fromCache);
            if (result.success) {
                return {
                    success: true,
                    data: result.data,
                    timing: {
                        durationMs: duration,
                        fromCache: result.fromCache,
                    },
                };
            }
            else {
                return {
                    success: false,
                    errors: result.errors,
                    timing: {
                        durationMs: duration,
                        fromCache: result.fromCache,
                    },
                };
            }
        }
        catch (error) {
            const duration = Date.now() - startTime;
            return {
                success: false,
                errors: [
                    {
                        path: [],
                        code: 'VALIDATION_SYSTEM_ERROR',
                        message: `Validation system error: ${error instanceof Error ? error.message : String(error)}`,
                        context: { originalError: error },
                    },
                ],
                timing: {
                    durationMs: duration,
                    fromCache: false,
                },
            };
        }
    }
    /**
     * Validates tool configuration against the provided schema
     */
    async validateConfig(config, schema, _options = {}) {
        const startTime = Date.now();
        try {
            // Build Zod schema for config validation
            const zodSchema = this.buildConfigSchema(schema, _options);
            // Perform validation
            const result = await this.performValidation(zodSchema, config, _options);
            const duration = Date.now() - startTime;
            this.updateMetrics(duration, result.fromCache);
            if (result.success) {
                return {
                    success: true,
                    data: result.data,
                    timing: {
                        durationMs: duration,
                        fromCache: result.fromCache,
                    },
                };
            }
            else {
                return {
                    success: false,
                    errors: result.errors,
                    timing: {
                        durationMs: duration,
                        fromCache: result.fromCache,
                    },
                };
            }
        }
        catch (error) {
            const duration = Date.now() - startTime;
            return {
                success: false,
                errors: [
                    {
                        path: [],
                        code: 'VALIDATION_SYSTEM_ERROR',
                        message: `Configuration validation system error: ${error instanceof Error ? error.message : String(error)}`,
                        context: { originalError: error },
                    },
                ],
                timing: {
                    durationMs: duration,
                    fromCache: false,
                },
            };
        }
    }
    /**
     * Validates complete tool schema including cross-field validations
     */
    async validateToolSchema(data, schema, _options = {}) {
        const startTime = Date.now();
        try {
            // Validate input and config separately first
            const inputResult = await this.validateInput(data.input, schema.input, _options);
            if (!inputResult.success) {
                return inputResult;
            }
            const configResult = await this.validateConfig(data.config, schema.config, _options);
            if (!configResult.success) {
                return configResult;
            }
            // Perform cross-field validations if defined
            if (schema.validation?.crossFieldValidation) {
                const crossFieldResult = await this.validateCrossFieldRules({ input: inputResult.data, config: configResult.data }, schema.validation.crossFieldValidation, _options);
                if (!crossFieldResult.success) {
                    return crossFieldResult;
                }
            }
            const duration = Date.now() - startTime;
            return {
                success: true,
                data: {
                    input: inputResult.data,
                    config: configResult.data,
                },
                timing: {
                    durationMs: duration,
                    fromCache: false, // Cross-field validation doesn't use cache
                },
            };
        }
        catch (error) {
            const duration = Date.now() - startTime;
            return {
                success: false,
                errors: [
                    {
                        path: [],
                        code: 'SCHEMA_VALIDATION_ERROR',
                        message: `Tool schema validation error: ${error instanceof Error ? error.message : String(error)}`,
                        context: { originalError: error },
                    },
                ],
                timing: {
                    durationMs: duration,
                    fromCache: false,
                },
            };
        }
    }
    /**
     * Builds a Zod schema from ToolInputField definitions
     */
    buildInputSchema(schema, _options) {
        const cacheKey = this.generateCacheKey('input', schema, _options);
        const cached = this.getFromCache(cacheKey);
        if (cached) {
            return cached.schema;
        }
        const zodFields = {};
        for (const [fieldName, fieldDef] of Object.entries(schema)) {
            zodFields[fieldName] = this.buildFieldSchema(fieldDef, fieldName, _options);
        }
        const zodSchema = z.object(zodFields);
        const finalSchema = _options.stripUnknown ? zodSchema.strip() : zodSchema;
        // Cache the schema
        this.setCache(cacheKey, finalSchema, schema);
        return finalSchema;
    }
    /**
     * Builds a Zod schema from ToolConfigField definitions
     */
    buildConfigSchema(schema, _options) {
        const cacheKey = this.generateCacheKey('config', schema, _options);
        const cached = this.getFromCache(cacheKey);
        if (cached) {
            return cached.schema;
        }
        const zodFields = {};
        for (const [fieldName, fieldDef] of Object.entries(schema)) {
            zodFields[fieldName] = this.buildConfigFieldSchema(fieldDef, fieldName, _options);
        }
        const zodSchema = z.object(zodFields);
        const finalSchema = _options.stripUnknown ? zodSchema.strip() : zodSchema;
        // Cache the schema
        this.setCache(cacheKey, finalSchema, schema);
        return finalSchema;
    }
    /**
     * Builds a Zod schema for a single input field
     */
    buildFieldSchema(field, fieldName, _options) {
        let schema;
        // Build base schema based on field type
        switch (field.type) {
            case 'string':
                schema = z.string();
                // Apply string-specific validations
                if (field.minLength !== undefined) {
                    schema = schema.min(field.minLength, _options.customMessages?.[`${fieldName}.minLength`] ||
                        `${fieldName} must be at least ${field.minLength} characters long`);
                }
                if (field.maxLength !== undefined) {
                    schema = schema.max(field.maxLength, _options.customMessages?.[`${fieldName}.maxLength`] ||
                        `${fieldName} must be at most ${field.maxLength} characters long`);
                }
                if (field.pattern) {
                    schema = schema.regex(new RegExp(field.pattern), _options.customMessages?.[`${fieldName}.pattern`] ||
                        `${fieldName} does not match required pattern`);
                }
                if (field.format) {
                    schema = this.applyStringFormat(schema, field.format, fieldName);
                }
                // Apply transformations
                if (_options.transform && field.transform) {
                    schema = this.applyStringTransform(schema, field.transform);
                }
                break;
            case 'email':
                schema = z
                    .string()
                    .email(_options.customMessages?.[`${fieldName}.email`] ||
                    `${fieldName} must be a valid email address`);
                break;
            case 'url':
                schema = z
                    .string()
                    .url(_options.customMessages?.[`${fieldName}.url`] ||
                    `${fieldName} must be a valid URL`);
                break;
            case 'uuid':
                schema = z
                    .string()
                    .uuid(_options.customMessages?.[`${fieldName}.uuid`] ||
                    `${fieldName} must be a valid UUID`);
                break;
            case 'number':
                schema = z.number();
                if (field.min !== undefined) {
                    schema = schema.min(field.min, _options.customMessages?.[`${fieldName}.min`] ||
                        `${fieldName} must be at least ${field.min}`);
                }
                if (field.max !== undefined) {
                    schema = schema.max(field.max, _options.customMessages?.[`${fieldName}.max`] ||
                        `${fieldName} must be at most ${field.max}`);
                }
                if (field.integer) {
                    schema = schema.int(_options.customMessages?.[`${fieldName}.integer`] ||
                        `${fieldName} must be an integer`);
                }
                break;
            case 'boolean':
                schema = z.boolean();
                break;
            case 'array': {
                let itemSchema = z.any();
                if (field.items) {
                    itemSchema = this.buildFieldSchema(field.items, `${fieldName}[item]`, _options);
                }
                schema = z.array(itemSchema);
                if (field.minItems !== undefined) {
                    schema = schema.min(field.minItems, _options.customMessages?.[`${fieldName}.minItems`] ||
                        `${fieldName} must contain at least ${field.minItems} items`);
                }
                if (field.maxItems !== undefined) {
                    schema = schema.max(field.maxItems, _options.customMessages?.[`${fieldName}.maxItems`] ||
                        `${fieldName} must contain at most ${field.maxItems} items`);
                }
                break;
            }
            case 'object':
                if (field.properties) {
                    const objectFields = {};
                    for (const [propName, propDef] of Object.entries(field.properties)) {
                        objectFields[propName] = this.buildFieldSchema(propDef, `${fieldName}.${propName}`, _options);
                    }
                    schema = z.object(objectFields);
                    if (!field.additionalProperties) {
                        schema = schema.strict();
                    }
                }
                else {
                    schema = z.record(z.string(), z.any());
                }
                break;
            case 'date':
                schema = z.coerce.date();
                if (field.minDate) {
                    const minDate = new Date(field.minDate);
                    schema = schema.min(minDate, _options.customMessages?.[`${fieldName}.minDate`] ||
                        `${fieldName} must be after ${field.minDate}`);
                }
                if (field.maxDate) {
                    const maxDate = new Date(field.maxDate);
                    schema = schema.max(maxDate, _options.customMessages?.[`${fieldName}.maxDate`] ||
                        `${fieldName} must be before ${field.maxDate}`);
                }
                break;
            case 'datetime':
                schema = z.coerce.date();
                // Additional datetime-specific validations could be added here
                break;
            case 'time':
                schema = z
                    .string()
                    .regex(/^([01]?[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9]$/, _options.customMessages?.[`${fieldName}.time`] ||
                    `${fieldName} must be in HH:MM:SS format`);
                break;
            case 'enum':
                if (!field.enum || field.enum.length === 0) {
                    throw new Error(`Enum field ${fieldName} must have enum values defined`);
                }
                schema = z.enum(field.enum);
                break;
            case 'json':
                schema = z.any().refine(val => {
                    try {
                        if (typeof val === 'string') {
                            JSON.parse(val);
                        }
                        return true;
                    }
                    catch {
                        return false;
                    }
                }, _options.customMessages?.[`${fieldName}.json`] ||
                    `${fieldName} must be valid JSON`);
                break;
            case 'file':
                // File validation would typically be handled at a higher level
                schema = z.object({
                    name: z.string(),
                    size: z.number(),
                    type: z.string(),
                });
                if (field.maxFileSize) {
                    schema = schema.refine((file) => file.size <= field.maxFileSize, _options.customMessages?.[`${fieldName}.maxFileSize`] ||
                        `${fieldName} file size must not exceed ${field.maxFileSize} bytes`);
                }
                if (field.allowedMimeTypes && field.allowedMimeTypes.length > 0) {
                    schema = schema.refine((file) => field.allowedMimeTypes.includes(file.type), _options.customMessages?.[`${fieldName}.mimeType`] ||
                        `${fieldName} must be one of the allowed file types: ${field.allowedMimeTypes.join(', ')}`);
                }
                break;
            default:
                schema = z.any();
                break;
        }
        // Apply enum validation if defined (for non-enum types)
        if (field.enum && field.type !== 'enum') {
            schema = schema.refine(val => field.enum.includes(val), _options.customMessages?.[`${fieldName}.enum`] ||
                `${fieldName} must be one of: ${field.enum.join(', ')}`);
        }
        // Handle required/optional and defaults
        if (!field.required) {
            schema = schema.optional();
            if (field.default !== undefined) {
                schema = schema.default(field.default);
            }
        }
        return schema;
    }
    /**
     * Builds a Zod schema for a single config field
     */
    buildConfigFieldSchema(field, fieldName, _options) {
        let schema;
        switch (field.type) {
            case 'string':
                schema = z.string();
                break;
            case 'apiKey':
            case 'secret':
                schema = z.string().min(1, `${fieldName} cannot be empty`);
                break;
            case 'url':
                schema = z.string().url(`${fieldName} must be a valid URL`);
                if (field.validation?.allowedProtocols) {
                    schema = schema.refine(url => {
                        try {
                            const parsed = new URL(url);
                            return field.validation.allowedProtocols.includes(parsed.protocol.slice(0, -1));
                        }
                        catch {
                            return false;
                        }
                    }, `${fieldName} must use one of the allowed protocols: ${field.validation.allowedProtocols.join(', ')}`);
                }
                break;
            case 'number':
                schema = z.number();
                break;
            case 'boolean':
                schema = z.boolean();
                break;
            case 'enum':
                if (!field.validation?.enum || field.validation.enum.length === 0) {
                    throw new Error(`Enum config field ${fieldName} must have enum values defined`);
                }
                schema = z.enum(field.validation.enum);
                break;
            case 'json':
                schema = z.any();
                if (field.validation?.jsonSchema) {
                    // Here you could integrate with a JSON Schema validator if needed
                    // For now, we'll just ensure it's valid JSON
                    schema = schema.refine(val => {
                        try {
                            if (typeof val === 'string') {
                                JSON.parse(val);
                            }
                            return true;
                        }
                        catch {
                            return false;
                        }
                    }, `${fieldName} must be valid JSON`);
                }
                break;
            default:
                schema = z.any();
                break;
        }
        // Apply validation rules
        if (field.validation) {
            const validation = field.validation;
            if (validation.min !== undefined && schema instanceof z.ZodString) {
                schema = schema.min(validation.min, validation.errorMessage ||
                    `${fieldName} must be at least ${validation.min} characters long`);
            }
            if (validation.max !== undefined && schema instanceof z.ZodString) {
                schema = schema.max(validation.max, validation.errorMessage ||
                    `${fieldName} must be at most ${validation.max} characters long`);
            }
            if (validation.pattern && schema instanceof z.ZodString) {
                schema = schema.regex(new RegExp(validation.pattern), validation.errorMessage ||
                    `${fieldName} does not match required pattern`);
            }
        }
        // Handle required/optional and defaults
        if (!field.required) {
            schema = schema.optional();
            if (field.default !== undefined) {
                schema = schema.default(field.default);
            }
        }
        return schema;
    }
    /**
     * Applies string format validation
     */
    applyStringFormat(schema, format, fieldName) {
        switch (format) {
            case 'email':
                return schema.email(`${fieldName} must be a valid email address`);
            case 'url':
                return schema.url(`${fieldName} must be a valid URL`);
            case 'uuid':
                return schema.uuid(`${fieldName} must be a valid UUID`);
            case 'ipv4':
                return schema.regex(/^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/, `${fieldName} must be a valid IPv4 address`);
            case 'ipv6':
                return schema.regex(/^(?:[0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}$|^::1$|^::$/, `${fieldName} must be a valid IPv6 address`);
            case 'base64':
                return schema.regex(/^[A-Za-z0-9+/]*={0,2}$/, `${fieldName} must be valid base64`);
            case 'jwt':
                return schema.regex(/^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/, `${fieldName} must be a valid JWT`);
            case 'slug':
                return schema.regex(/^[a-z0-9]+(?:-[a-z0-9]+)*$/, `${fieldName} must be a valid slug`);
            case 'color-hex':
                return schema.regex(/^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/, `${fieldName} must be a valid hex color`);
            case 'semver':
                return schema.regex(/^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$/, `${fieldName} must be a valid semantic version`);
            default:
                return schema;
        }
    }
    /**
     * Applies string transformations
     */
    applyStringTransform(schema, transform) {
        switch (transform) {
            case 'trim':
                return schema.transform(val => val.trim());
            case 'lowercase':
                return schema.transform(val => val.toLowerCase());
            case 'uppercase':
                return schema.transform(val => val.toUpperCase());
            case 'normalize':
                return schema.transform(val => val.normalize());
            default:
                return schema;
        }
    }
    /**
     * Performs the actual validation using Zod
     */
    async performValidation(schema, data, _options) {
        try {
            const result = schema.safeParse(data);
            if (result.success) {
                return {
                    success: true,
                    data: result.data,
                    fromCache: false, // TODO: Implement result caching if needed
                };
            }
            else {
                const errors = this.convertZodErrors(result.error);
                return {
                    success: false,
                    errors,
                    fromCache: false,
                };
            }
        }
        catch (error) {
            return {
                success: false,
                errors: [
                    {
                        path: [],
                        code: 'PARSE_ERROR',
                        message: `Parsing error: ${error instanceof Error ? error.message : String(error)}`,
                        context: { originalError: error },
                    },
                ],
                fromCache: false,
            };
        }
    }
    /**
     * Validates cross-field rules
     */
    async validateCrossFieldRules(data, rules, _options) {
        const errors = [];
        for (const rule of rules) {
            try {
                const isValid = await this.evaluateCrossFieldRule(data, rule, _options);
                if (!isValid) {
                    errors.push({
                        path: ['cross-field'],
                        code: 'CROSS_FIELD_VALIDATION_FAILED',
                        message: rule.errorMessage ||
                            rule.description ||
                            'Cross-field validation failed',
                        context: { rule },
                    });
                }
            }
            catch (error) {
                errors.push({
                    path: ['cross-field'],
                    code: 'CROSS_FIELD_EVALUATION_ERROR',
                    message: `Error evaluating cross-field rule: ${error instanceof Error ? error.message : String(error)}`,
                    context: { rule, error },
                });
            }
        }
        return {
            success: errors.length === 0,
            ...(errors.length > 0 && { errors }),
        };
    }
    /**
     * Evaluates a single cross-field rule
     */
    async evaluateCrossFieldRule(data, rule, _options) {
        switch (rule.rule) {
            case 'conditional':
                if (rule.condition) {
                    // Simple condition evaluation (in production, you might want a safer evaluator)
                    const conditionMet = this.evaluateCondition(rule.condition, data);
                    if (conditionMet) {
                        // Check if required fields are present
                        if (rule.requires) {
                            for (const fieldPath of rule.requires) {
                                if (!this.getNestedValue(data, fieldPath)) {
                                    return false;
                                }
                            }
                        }
                        // Check if forbidden fields are absent
                        if (rule.forbids) {
                            for (const fieldPath of rule.forbids) {
                                if (this.getNestedValue(data, fieldPath)) {
                                    return false;
                                }
                            }
                        }
                    }
                }
                return true;
            case 'mutual_exclusion':
                // Check that only one of the specified fields is present
                if (rule.fields) {
                    const presentFields = rule.fields.filter((fieldPath) => this.getNestedValue(data, fieldPath) !== undefined);
                    return presentFields.length <= 1;
                }
                return true;
            case 'dependency':
                // Check that if one field is present, others are required
                if (rule.trigger && rule.requires) {
                    const triggerPresent = this.getNestedValue(data, rule.trigger) !== undefined;
                    if (triggerPresent) {
                        for (const requiredField of rule.requires) {
                            if (this.getNestedValue(data, requiredField) === undefined) {
                                return false;
                            }
                        }
                    }
                }
                return true;
            case 'custom':
                // For custom validations, you would implement your own logic here
                // This is a placeholder for custom validation functions
                return true;
            default:
                throw new Error(`Unknown cross-field validation rule: ${rule.rule}`);
        }
    }
    /**
     * Simple condition evaluator (for production, consider using a safer expression evaluator)
     */
    evaluateCondition(condition, data) {
        try {
            // This is a simplified evaluator. In production, you should use a safer
            // expression evaluator that doesn't use eval()
            const context = { input: data.input, config: data.config };
            // Replace field references with actual values
            let processedCondition = condition;
            // Simple regex-based replacement for common patterns
            processedCondition = processedCondition.replace(/input\.(\w+)/g, (_, fieldName) => {
                const value = context.input[fieldName];
                return typeof value === 'string' ? `"${value}"` : String(value);
            });
            processedCondition = processedCondition.replace(/config\.(\w+)/g, (_, fieldName) => {
                const value = context.config[fieldName];
                return typeof value === 'string' ? `"${value}"` : String(value);
            });
            // WARNING: This uses eval() which is dangerous in production
            // Consider using a proper expression evaluator library
            return Boolean(eval(processedCondition));
        }
        catch {
            return false;
        }
    }
    /**
     * Gets a nested value from an object using dot notation
     */
    getNestedValue(obj, path) {
        return path.split('.').reduce((current, key) => {
            return current && current[key] !== undefined ? current[key] : undefined;
        }, obj);
    }
    /**
     * Converts Zod errors to our standardized format
     */
    convertZodErrors(zodError) {
        return zodError.issues.map(error => ({
            path: error.path.map(p => String(p)),
            code: error.code.toUpperCase(),
            message: error.message,
            value: error.received,
            expected: error.expected,
            context: {
                zodError: error,
            },
        }));
    }
    /**
     * Cache management methods
     */
    generateCacheKey(type, schema, options) {
        const schemaHash = this.hashObject(schema);
        const optionsHash = this.hashObject(options);
        return `${type}:${schemaHash}:${optionsHash}`;
    }
    getFromCache(cacheKey) {
        const cached = this.schemaCache.get(cacheKey);
        if (!cached) {
            return null;
        }
        // Check if cache entry is still valid
        const isExpired = Date.now() - cached.timestamp > ZodSchemaValidator.CACHE_TTL_MS;
        if (isExpired) {
            this.schemaCache.delete(cacheKey);
            return null;
        }
        // Update hit count
        cached.hitCount++;
        this.metrics.cacheHits++;
        return cached;
    }
    setCache(cacheKey, schema, originalSchema) {
        // Cleanup old entries if cache is full
        if (this.schemaCache.size >= ZodSchemaValidator.MAX_CACHE_SIZE) {
            this.cleanupCache();
        }
        this.schemaCache.set(cacheKey, {
            schema,
            timestamp: Date.now(),
            hitCount: 0,
            hash: this.hashObject(originalSchema),
        });
    }
    cleanupCache() {
        // Remove least recently used entries
        const entries = Array.from(this.schemaCache.entries());
        entries.sort((a, b) => a[1].timestamp - b[1].timestamp);
        // Remove oldest 25% of entries
        const toRemove = Math.floor(entries.length * 0.25);
        for (let i = 0; i < toRemove; i++) {
            this.schemaCache.delete(entries[i][0]);
        }
    }
    hashObject(obj) {
        // Simple hash function for caching purposes
        const str = JSON.stringify(obj, Object.keys(obj).sort());
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            const char = str.charCodeAt(i);
            hash = (hash << 5) - hash + char;
            hash = hash & hash; // Convert to 32-bit integer
        }
        return hash.toString(36);
    }
    /**
     * Updates performance metrics
     */
    updateMetrics(durationMs, fromCache) {
        this.metrics.totalValidations++;
        this.metrics.totalDurationMs += durationMs;
        this.metrics.averageDurationMs =
            this.metrics.totalDurationMs / this.metrics.totalValidations;
        if (fromCache) {
            this.metrics.cacheHits++;
        }
    }
    /**
     * Gets performance metrics
     */
    getMetrics() {
        return {
            ...this.metrics,
            cacheHitRate: this.metrics.totalValidations > 0
                ? this.metrics.cacheHits / this.metrics.totalValidations
                : 0,
            currentCacheSize: this.schemaCache.size,
        };
    }
    /**
     * Clears all caches and resets metrics
     */
    reset() {
        this.schemaCache.clear();
        this.metrics.totalValidations = 0;
        this.metrics.cacheHits = 0;
        this.metrics.averageDurationMs = 0;
        this.metrics.totalDurationMs = 0;
    }
}
/**
 * Legacy compatibility layer for existing SchemaValidator API
 * @deprecated Use ZodSchemaValidator instead
 */
class SchemaValidator {
    static validator = new ZodSchemaValidator();
    /**
     * @deprecated Use ZodSchemaValidator.validateInput instead
     */
    static async validateInput(input, schema) {
        const result = await this.validator.validateInput(input, schema);
        if (!result.success) {
            const errorMessages = result.errors.map(e => e.message);
            throw new ValidationError(`Input validation failed: ${errorMessages.join(', ')}`, result.errors[0]?.path.join('.'), { errors: result.errors });
        }
    }
    /**
     * @deprecated Use ZodSchemaValidator.validateConfig instead
     */
    static async validateConfig(config, schema) {
        const result = await this.validator.validateConfig(config, schema);
        if (!result.success) {
            const errorMessages = result.errors.map(e => e.message);
            const missingKeys = result
                .errors.filter(e => e.code === 'REQUIRED')
                .map(e => e.path.join('.'));
            throw new ConfigurationError(`Configuration validation failed: ${errorMessages.join(', ')}`, missingKeys);
        }
    }
}

/**
 * Field builder system for creating tool input and configuration schemas.
 * This module provides a fluent API for defining validation rules in a type-safe manner.
 *
 * @example
 * ```typescript
 * import { stringField, numberField, enumField } from '@ai-spine/tools-core';
 *
 * const schema = {
 *   input: {
 *     city: stringField()
 *       .required()
 *       .minLength(2)
 *       .maxLength(100)
 *       .description('Name of the city to get weather for')
 *       .example('Madrid'),
 *
 *     temperature_units: enumField(['celsius', 'fahrenheit', 'kelvin'])
 *       .optional()
 *       .default('celsius')
 *       .description('Temperature units for response'),
 *
 *     max_results: numberField()
 *       .optional()
 *       .min(1)
 *       .max(10)
 *       .integer()
 *       .default(5)
 *   },
 *   config: {
 *     apiKey: apiKeyField()
 *       .required()
 *       .description('OpenWeatherMap API key')
 *       .envVar('OPENWEATHER_API_KEY')
 *   }
 * };
 * ```
 */
// ===== INPUT FIELD BUILDERS =====
/**
 * Base builder class for input fields. Provides common validation methods
 * that are shared across all field types.
 */
class BaseInputFieldBuilder {
    field = {};
    /**
     * Mark this field as required for tool execution
     */
    required() {
        this.field.required = true;
        return this;
    }
    /**
     * Mark this field as optional (default behavior)
     */
    optional() {
        this.field.required = false;
        return this;
    }
    /**
     * Set a human-readable description for this field
     */
    description(desc) {
        this.field.description = desc;
        return this;
    }
    /**
     * Set a default value for optional fields
     */
    default(value) {
        this.field.default = value;
        this.field.required = false; // Defaults imply optional
        return this;
    }
    /**
     * Set an example value for documentation and testing
     */
    example(value) {
        this.field.example = value;
        return this;
    }
    /**
     * Mark this field as containing sensitive data
     */
    sensitive() {
        this.field.sensitive = true;
        return this;
    }
    /**
     * Enable sanitization for this field
     */
    sanitize() {
        this.field.sanitize = true;
        return this;
    }
    /**
     * Set transformation to apply before validation
     */
    transform(transformation) {
        this.field.transform = transformation;
        return this;
    }
}
/**
 * Builder for string input fields
 */
class StringFieldBuilder extends BaseInputFieldBuilder {
    constructor() {
        super();
        this.field.type = 'string';
    }
    /**
     * Set minimum string length
     */
    minLength(length) {
        this.field.minLength = length;
        return this;
    }
    /**
     * Set maximum string length
     */
    maxLength(length) {
        this.field.maxLength = length;
        return this;
    }
    /**
     * Set regex pattern for validation
     */
    pattern(regex) {
        this.field.pattern = regex;
        return this;
    }
    /**
     * Set string format validation
     */
    format(fmt) {
        this.field.format = fmt;
        return this;
    }
    build() {
        return { ...this.field };
    }
}
/**
 * Builder for number input fields
 */
class NumberFieldBuilder extends BaseInputFieldBuilder {
    constructor() {
        super();
        this.field.type = 'number';
    }
    /**
     * Set minimum numeric value
     */
    min(value) {
        this.field.min = value;
        return this;
    }
    /**
     * Set maximum numeric value
     */
    max(value) {
        this.field.max = value;
        return this;
    }
    /**
     * Require the number to be an integer
     */
    integer() {
        this.field.integer = true;
        return this;
    }
    /**
     * Set number of decimal places allowed
     */
    precision(places) {
        this.field.precision = places;
        return this;
    }
    build() {
        return { ...this.field };
    }
}
/**
 * Builder for boolean input fields
 */
class BooleanFieldBuilder extends BaseInputFieldBuilder {
    constructor() {
        super();
        this.field.type = 'boolean';
    }
    build() {
        return { ...this.field };
    }
}
/**
 * Builder for enum input fields
 */
class EnumFieldBuilder extends BaseInputFieldBuilder {
    constructor(values) {
        super();
        this.field.type = 'enum';
        this.field.enum = values;
    }
    /**
     * Set human-readable labels for enum values
     */
    labels(labels) {
        this.field.enumLabels = labels;
        return this;
    }
    build() {
        return { ...this.field };
    }
}
/**
 * Builder for array input fields
 */
class ArrayFieldBuilder extends BaseInputFieldBuilder {
    constructor(itemType) {
        super();
        this.field.type = 'array';
        this.field.items = itemType;
    }
    /**
     * Set minimum array length
     */
    minItems(count) {
        this.field.minItems = count;
        return this;
    }
    /**
     * Set maximum array length
     */
    maxItems(count) {
        this.field.maxItems = count;
        return this;
    }
    /**
     * Require array items to be unique
     */
    unique() {
        this.field.uniqueItems = true;
        return this;
    }
    build() {
        return { ...this.field };
    }
}
/**
 * Builder for object input fields
 */
class ObjectFieldBuilder extends BaseInputFieldBuilder {
    constructor(properties) {
        super();
        this.field.type = 'object';
        this.field.properties = properties;
    }
    /**
     * Set required properties for the object
     */
    requiredProperties(props) {
        this.field.requiredProperties = props;
        return this;
    }
    /**
     * Allow additional properties beyond those defined
     */
    additionalProperties(allowed = true) {
        this.field.additionalProperties = allowed;
        return this;
    }
    build() {
        return { ...this.field };
    }
}
/**
 * Builder for date input fields
 */
class DateFieldBuilder extends BaseInputFieldBuilder {
    constructor() {
        super();
        this.field.type = 'date';
    }
    /**
     * Set minimum date value
     */
    minDate(date) {
        this.field.minDate = date;
        return this;
    }
    /**
     * Set maximum date value
     */
    maxDate(date) {
        this.field.maxDate = date;
        return this;
    }
    build() {
        return { ...this.field };
    }
}
/**
 * Builder for datetime input fields
 */
class DateTimeFieldBuilder extends BaseInputFieldBuilder {
    constructor() {
        super();
        this.field.type = 'datetime';
    }
    /**
     * Set minimum datetime value
     */
    minDate(date) {
        this.field.minDate = date;
        return this;
    }
    /**
     * Set maximum datetime value
     */
    maxDate(date) {
        this.field.maxDate = date;
        return this;
    }
    /**
     * Set timezone requirement
     */
    timezone(requirement) {
        this.field.timezone = requirement;
        return this;
    }
    build() {
        return { ...this.field };
    }
}
/**
 * Builder for file input fields
 */
class FileFieldBuilder extends BaseInputFieldBuilder {
    constructor() {
        super();
        this.field.type = 'file';
    }
    /**
     * Set allowed MIME types
     */
    mimeTypes(types) {
        this.field.allowedMimeTypes = types;
        return this;
    }
    /**
     * Set maximum file size in bytes
     */
    maxSize(bytes) {
        this.field.maxFileSize = bytes;
        return this;
    }
    build() {
        return { ...this.field };
    }
}
// ===== CONFIG FIELD BUILDERS =====
/**
 * Base builder for configuration fields
 */
class BaseConfigFieldBuilder {
    field = {};
    /**
     * Mark this configuration field as required
     */
    required() {
        this.field.required = true;
        return this;
    }
    /**
     * Mark this configuration field as optional
     */
    optional() {
        this.field.required = false;
        return this;
    }
    /**
     * Set description for this configuration field
     */
    description(desc) {
        this.field.description = desc;
        return this;
    }
    /**
     * Set default value for optional configuration
     */
    default(value) {
        this.field.default = value;
        this.field.required = false;
        return this;
    }
    /**
     * Mark this field as containing sensitive data
     */
    secret() {
        this.field.secret = true;
        return this;
    }
    /**
     * Set example value for documentation
     */
    example(value) {
        this.field.example = value;
        return this;
    }
    /**
     * Set environment variable name for loading this config
     */
    envVar(name) {
        this.field.envVar = name;
        return this;
    }
    /**
     * Set category for grouping related configs
     */
    category(cat) {
        this.field.category = cat;
        return this;
    }
    /**
     * Allow runtime override of this configuration
     */
    allowRuntimeOverride() {
        this.field.allowRuntimeOverride = true;
        return this;
    }
}
/**
 * Builder for API key configuration fields
 */
class ApiKeyFieldBuilder extends BaseConfigFieldBuilder {
    constructor() {
        super();
        this.field.type = 'apiKey';
        this.field.secret = true; // API keys are always secret
    }
    /**
     * Set regex pattern for API key validation
     */
    pattern(regex) {
        this.field.validation = { ...this.field.validation, pattern: regex };
        return this;
    }
    /**
     * Set custom error message for validation failures
     */
    errorMessage(message) {
        this.field.validation = { ...this.field.validation, errorMessage: message };
        return this;
    }
    build() {
        return { ...this.field };
    }
}
/**
 * Builder for string configuration fields
 */
class ConfigStringFieldBuilder extends BaseConfigFieldBuilder {
    constructor() {
        super();
        this.field.type = 'string';
    }
    /**
     * Set minimum string length
     */
    minLength(length) {
        this.field.validation = { ...this.field.validation, min: length };
        return this;
    }
    /**
     * Set maximum string length
     */
    maxLength(length) {
        this.field.validation = { ...this.field.validation, max: length };
        return this;
    }
    /**
     * Set regex pattern for validation
     */
    pattern(regex) {
        this.field.validation = { ...this.field.validation, pattern: regex };
        return this;
    }
    build() {
        return { ...this.field };
    }
}
/**
 * Builder for URL configuration fields
 */
class UrlConfigFieldBuilder extends BaseConfigFieldBuilder {
    constructor() {
        super();
        this.field.type = 'url';
    }
    /**
     * Set allowed protocols (e.g., ['https', 'http'])
     */
    protocols(protocols) {
        this.field.validation = {
            ...this.field.validation,
            allowedProtocols: protocols,
        };
        return this;
    }
    build() {
        return { ...this.field };
    }
}
/**
 * Builder for enum configuration fields
 */
class ConfigEnumFieldBuilder extends BaseConfigFieldBuilder {
    constructor(values) {
        super();
        this.field.type = 'enum';
        this.field.validation = { enum: values };
    }
    build() {
        return { ...this.field };
    }
}
// ===== EXPORTED FACTORY FUNCTIONS =====
/**
 * Create a string input field builder
 */
function stringField() {
    return new StringFieldBuilder();
}
/**
 * Create a number input field builder
 */
function numberField() {
    return new NumberFieldBuilder();
}
/**
 * Create a boolean input field builder
 */
function booleanField() {
    return new BooleanFieldBuilder();
}
/**
 * Create an enum input field builder
 */
function enumField(values) {
    return new EnumFieldBuilder(values);
}
/**
 * Create an array input field builder
 */
function arrayField(itemType) {
    return new ArrayFieldBuilder(itemType);
}
/**
 * Create an object input field builder
 */
function objectField(properties) {
    return new ObjectFieldBuilder(properties);
}
/**
 * Create a date input field builder
 */
function dateField() {
    return new DateFieldBuilder();
}
/**
 * Create a datetime input field builder
 */
function datetimeField() {
    return new DateTimeFieldBuilder();
}
/**
 * Create a file input field builder
 */
function fileField() {
    return new FileFieldBuilder();
}
/**
 * Create an API key configuration field builder
 */
function apiKeyField() {
    return new ApiKeyFieldBuilder();
}
/**
 * Create a string configuration field builder
 */
function configStringField() {
    return new ConfigStringFieldBuilder();
}
/**
 * Create a URL configuration field builder
 */
function urlConfigField() {
    return new UrlConfigFieldBuilder();
}
/**
 * Create an enum configuration field builder
 */
function configEnumField(values) {
    return new ConfigEnumFieldBuilder(values);
}
// ===== CONVENIENCE FUNCTIONS =====
/**
 * Quick builder for commonly used email fields
 */
function emailField() {
    return stringField().format('email').transform('lowercase');
}
/**
 * Quick builder for commonly used URL fields
 */
function urlField() {
    return stringField().format('url');
}
/**
 * Quick builder for UUID fields
 */
function uuidField() {
    return stringField().format('uuid');
}
/**
 * Quick builder for time fields
 */
function timeField() {
    return new (class extends BaseInputFieldBuilder {
        constructor() {
            super();
            this.field.type = 'time';
        }
        build() {
            return { ...this.field };
        }
    })();
}
// ===== DOCUMENTATION GENERATION UTILITIES =====
/**
 * Documentation generator that creates OpenAPI-style documentation from field definitions
 */
class DocumentationGenerator {
    /**
     * Generate OpenAPI schema from field definition
     */
    static generateOpenAPISchema(field) {
        const schema = {
            type: this.mapToOpenAPIType(field.type),
        };
        // Add description
        if (field.description) {
            schema.description = field.description;
        }
        // Add example
        if (field.example !== undefined) {
            schema.example = field.example;
        }
        // Add default value
        if (field.default !== undefined) {
            schema.default = field.default;
        }
        // Type-specific properties
        switch (field.type) {
            case 'string':
                this.addStringProperties(schema, field);
                break;
            case 'number':
                this.addNumberProperties(schema, field);
                break;
            case 'array':
                this.addArrayProperties(schema, field);
                break;
            case 'object':
                this.addObjectProperties(schema, field);
                break;
            case 'enum':
                this.addEnumProperties(schema, field);
                break;
            case 'date':
                schema.format = 'date';
                this.addDateProperties(schema, field);
                break;
            case 'datetime':
                schema.format = 'date-time';
                this.addDateProperties(schema, field);
                break;
            case 'time':
                schema.format = 'time';
                break;
            case 'file':
                schema.format = 'binary';
                this.addFileProperties(schema, field);
                break;
        }
        return schema;
    }
    static mapToOpenAPIType(type) {
        const typeMap = {
            string: 'string',
            number: 'number',
            boolean: 'boolean',
            array: 'array',
            object: 'object',
            date: 'string',
            datetime: 'string',
            time: 'string',
            email: 'string',
            url: 'string',
            uuid: 'string',
            json: 'object',
            file: 'string',
            enum: 'string',
            apiKey: 'string',
        };
        return typeMap[type] || 'string';
    }
    static addStringProperties(schema, field) {
        if ('minLength' in field && field.minLength !== undefined)
            schema.minLength = field.minLength;
        if ('maxLength' in field && field.maxLength !== undefined)
            schema.maxLength = field.maxLength;
        if ('pattern' in field && field.pattern)
            schema.pattern = field.pattern;
        if ('format' in field && field.format)
            schema.format = field.format;
        // Add validation properties
        if ('validation' in field && field.validation) {
            if (field.validation.min !== undefined)
                schema.minLength = field.validation.min;
            if (field.validation.max !== undefined)
                schema.maxLength = field.validation.max;
            if (field.validation.pattern)
                schema.pattern = field.validation.pattern;
        }
    }
    static addNumberProperties(schema, field) {
        if ('min' in field && field.min !== undefined)
            schema.minimum = field.min;
        if ('max' in field && field.max !== undefined)
            schema.maximum = field.max;
        if ('integer' in field && field.integer)
            schema.type = 'integer';
        // Add validation properties
        if ('validation' in field && field.validation) {
            if (field.validation.min !== undefined)
                schema.minimum = field.validation.min;
            if (field.validation.max !== undefined)
                schema.maximum = field.validation.max;
        }
    }
    static addArrayProperties(schema, field) {
        if ('items' in field && field.items) {
            schema.items = this.generateOpenAPISchema(field.items);
        }
        if ('minItems' in field && field.minItems !== undefined)
            schema.minItems = field.minItems;
        if ('maxItems' in field && field.maxItems !== undefined)
            schema.maxItems = field.maxItems;
        if ('uniqueItems' in field && field.uniqueItems)
            schema.uniqueItems = true;
        // Add validation properties from field.validation
        // Note: Array validation properties would need to be added to the validation type interface
    }
    static addObjectProperties(schema, field) {
        if ('properties' in field && field.properties) {
            schema.properties = {};
            for (const [key, prop] of Object.entries(field.properties)) {
                schema.properties[key] = this.generateOpenAPISchema(prop);
            }
        }
        if ('requiredProperties' in field && field.requiredProperties?.length) {
            schema.required = field.requiredProperties;
        }
        if ('additionalProperties' in field &&
            field.additionalProperties !== undefined) {
            schema.additionalProperties = field.additionalProperties;
        }
    }
    static addEnumProperties(schema, field) {
        if ('enum' in field && field.enum) {
            schema.enum = field.enum;
        }
        // Handle config enum fields that store enum in validation
        if ('validation' in field &&
            field.validation &&
            'enum' in field.validation) {
            schema.enum = field.validation.enum;
        }
    }
    static addDateProperties(schema, field) {
        if ('minDate' in field && field.minDate)
            schema.minimum = field.minDate;
        if ('maxDate' in field && field.maxDate)
            schema.maximum = field.maxDate;
    }
    static addFileProperties(schema, field) {
        if ('allowedMimeTypes' in field && field.allowedMimeTypes?.length) {
            schema.contentMediaType = field.allowedMimeTypes[0];
            if (field.allowedMimeTypes.length > 1) {
                schema['x-allowed-mime-types'] = field.allowedMimeTypes;
            }
        }
        if ('maxFileSize' in field && field.maxFileSize) {
            schema['x-max-file-size'] = field.maxFileSize;
        }
    }
    /**
     * Generate complete tool documentation from schema
     */
    static generateToolDocumentation(schema, metadata) {
        const doc = {
            openapi: '3.0.3',
            info: {
                title: metadata?.name || 'AI Spine Tool',
                description: metadata?.description || 'An AI Spine compatible tool',
                version: metadata?.version || '1.0.0',
            },
            paths: {
                '/api/execute': {
                    post: {
                        summary: 'Execute the tool',
                        requestBody: {
                            required: true,
                            content: {
                                'application/json': {
                                    schema: {
                                        type: 'object',
                                        properties: {},
                                        required: [],
                                    },
                                },
                            },
                        },
                        responses: {
                            '200': {
                                description: 'Tool execution successful',
                                content: {
                                    'application/json': {
                                        schema: {
                                            type: 'object',
                                            properties: {
                                                success: { type: 'boolean' },
                                                data: { type: 'object' },
                                                executionTime: { type: 'number' },
                                                executionId: { type: 'string' },
                                            },
                                        },
                                    },
                                },
                            },
                            '400': {
                                description: 'Validation error',
                                content: {
                                    'application/json': {
                                        schema: {
                                            type: 'object',
                                            properties: {
                                                success: { type: 'boolean', enum: [false] },
                                                error: { type: 'string' },
                                                errors: {
                                                    type: 'array',
                                                    items: {
                                                        type: 'object',
                                                        properties: {
                                                            path: {
                                                                type: 'array',
                                                                items: { type: 'string' },
                                                            },
                                                            code: { type: 'string' },
                                                            message: { type: 'string' },
                                                        },
                                                    },
                                                },
                                            },
                                        },
                                    },
                                },
                            },
                        },
                    },
                },
                '/health': {
                    get: {
                        summary: 'Get tool health status',
                        responses: {
                            '200': {
                                description: 'Tool health information',
                                content: {
                                    'application/json': {
                                        schema: {
                                            type: 'object',
                                            properties: {
                                                status: {
                                                    type: 'string',
                                                    enum: ['healthy', 'degraded', 'unhealthy'],
                                                },
                                                uptime: { type: 'number' },
                                                version: { type: 'string' },
                                                metrics: { type: 'object' },
                                            },
                                        },
                                    },
                                },
                            },
                        },
                    },
                },
                '/schema': {
                    get: {
                        summary: 'Get tool schema documentation',
                        responses: {
                            '200': {
                                description: 'Tool schema information',
                                content: {
                                    'application/json': {
                                        schema: {
                                            type: 'object',
                                            properties: {
                                                metadata: { type: 'object' },
                                                schema: { type: 'object' },
                                                openapi: { type: 'object' },
                                            },
                                        },
                                    },
                                },
                            },
                        },
                    },
                },
            },
        };
        // Add input and config properties to request schema
        const requestSchema = doc.paths['/api/execute'].post.requestBody.content['application/json']
            .schema;
        if (schema.input && Object.keys(schema.input).length > 0) {
            requestSchema.properties.input_data = {
                type: 'object',
                properties: {},
                required: [],
            };
            for (const [key, field] of Object.entries(schema.input)) {
                requestSchema.properties.input_data.properties[key] =
                    this.generateOpenAPISchema(field);
                if (field.required) {
                    requestSchema.properties.input_data.required.push(key);
                }
            }
            requestSchema.required.push('input_data');
        }
        if (schema.config && Object.keys(schema.config).length > 0) {
            requestSchema.properties.config = {
                type: 'object',
                properties: {},
                required: [],
            };
            for (const [key, field] of Object.entries(schema.config)) {
                requestSchema.properties.config.properties[key] =
                    this.generateOpenAPISchema(field);
                if (field.required) {
                    requestSchema.properties.config.required.push(key);
                }
            }
        }
        return doc;
    }
}
// ===== SCHEMA VALIDATION UTILITIES =====
/**
 * Schema builder class that provides direct validation capabilities
 * along with field building functionality
 */
class SchemaBuilder {
    inputFields = {};
    configFields = {};
    validator = new ZodSchemaValidator();
    /**
     * Add an input field to the schema
     */
    addInput(name, field) {
        this.inputFields[name] = field;
        return this;
    }
    /**
     * Add a config field to the schema
     */
    addConfig(name, field) {
        this.configFields[name] = field;
        return this;
    }
    /**
     * Build the complete schema
     */
    build() {
        return {
            input: { ...this.inputFields },
            config: { ...this.configFields },
        };
    }
    /**
     * Validate input data against the current schema
     */
    async validateInput(data, options) {
        return this.validator.validateInput(data, this.inputFields, options);
    }
    /**
     * Validate config data against the current schema
     */
    async validateConfig(data, options) {
        return this.validator.validateConfig(data, this.configFields, options);
    }
    /**
     * Validate complete tool data (input + config)
     */
    async validateToolData(data, options) {
        const schema = {
            input: this.inputFields,
            config: this.configFields,
        };
        return this.validator.validateToolSchema(data, schema, options);
    }
    /**
     * Test a single field value against its definition
     */
    async testField(fieldName, value, type = 'input') {
        const fields = type === 'input' ? this.inputFields : this.configFields;
        const field = fields[fieldName];
        if (!field) {
            return {
                success: false,
                errors: [
                    {
                        path: [fieldName],
                        code: 'FIELD_NOT_FOUND',
                        message: `Field '${fieldName}' not found in ${type} schema`,
                    },
                ],
            };
        }
        const testSchema = { [fieldName]: field };
        const testData = { [fieldName]: value };
        if (type === 'input') {
            return this.validator.validateInput(testData, testSchema);
        }
        else {
            return this.validator.validateConfig(testData, testSchema);
        }
    }
    /**
     * Get performance metrics from the validator
     */
    getMetrics() {
        return this.validator.getMetrics();
    }
    /**
     * Reset validator cache and metrics
     */
    reset() {
        this.validator.reset();
    }
    /**
     * Generate OpenAPI documentation for the current schema
     */
    generateDocumentation(metadata) {
        const schema = this.build();
        return DocumentationGenerator.generateToolDocumentation(schema, metadata);
    }
    /**
     * Generate example request data based on the schema
     */
    generateExampleRequest() {
        const result = {};
        // Generate example input data
        if (Object.keys(this.inputFields).length > 0) {
            result.input_data = {};
            for (const [key, field] of Object.entries(this.inputFields)) {
                result.input_data[key] = this.generateExampleValue(field);
            }
        }
        // Generate example config data
        if (Object.keys(this.configFields).length > 0) {
            result.config = {};
            for (const [key, field] of Object.entries(this.configFields)) {
                result.config[key] = this.generateExampleValue(field);
            }
        }
        return result;
    }
    /**
     * Generate an example value for a field
     */
    generateExampleValue(field) {
        // Use explicit example if provided
        if (field.example !== undefined) {
            return field.example;
        }
        // Use default value if provided
        if (field.default !== undefined) {
            return field.default;
        }
        // Generate based on field type
        switch (field.type) {
            case 'string':
                if ('format' in field) {
                    if (field.format === 'email')
                        return 'user@example.com';
                    if (field.format === 'url')
                        return 'https://example.com';
                    if (field.format === 'uuid')
                        return '550e8400-e29b-41d4-a716-446655440000';
                }
                if ('enum' in field && field.enum)
                    return field.enum[0];
                return 'example string';
            case 'number': {
                if ('min' in field &&
                    'max' in field &&
                    field.min !== undefined &&
                    field.max !== undefined) {
                    return Math.floor((field.min + field.max) / 2);
                }
                if ('min' in field && field.min !== undefined)
                    return field.min;
                if ('max' in field && field.max !== undefined)
                    return field.max;
                const isInteger = 'integer' in field && field.integer;
                return isInteger ? 42 : 42.5;
            }
            case 'boolean':
                return true;
            case 'array':
                if ('items' in field && field.items) {
                    const itemExample = this.generateExampleValue(field.items);
                    return [itemExample];
                }
                return ['item'];
            case 'object': {
                const objExample = {};
                if ('properties' in field && field.properties) {
                    for (const [key, prop] of Object.entries(field.properties)) {
                        objExample[key] = this.generateExampleValue(prop);
                    }
                }
                return objExample;
            }
            case 'date':
                return '2023-12-25';
            case 'datetime':
                return '2023-12-25T12:00:00Z';
            case 'time':
                return '12:00:00';
            case 'enum':
                if ('enum' in field && field.enum)
                    return field.enum[0];
                // Handle config enum fields
                if ('validation' in field &&
                    field.validation &&
                    'enum' in field.validation &&
                    field.validation.enum) {
                    return field.validation.enum[0];
                }
                return 'option1';
            case 'apiKey':
                return 'sk-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx';
            case 'file':
                return 'file.txt';
            default:
                return 'example value';
        }
    }
}
/**
 * Create a new schema builder instance
 */
function createSchema() {
    return new SchemaBuilder();
}
/**
 * Validate a single field value quickly without building a full schema
 */
async function validateField(field, value, fieldName = 'field', options) {
    const validator = new ZodSchemaValidator();
    const schema = { [fieldName]: field };
    const data = { [fieldName]: value };
    // Check if this is a config field by looking at the type
    const isConfigField = 'type' in field &&
        (field.type === 'apiKey' ||
            field.type === 'secret' ||
            (field.type === 'url' && 'validation' in field) ||
            (field.type === 'json' &&
                'validation' in field &&
                'jsonSchema' in (field.validation || {})));
    if (isConfigField) {
        // This is a config field
        return validator.validateConfig(data, schema, options);
    }
    else {
        // This is an input field
        return validator.validateInput(data, schema, options);
    }
}
/**
 * Create a validation function for a specific schema
 */
function createValidator(schema) {
    const validator = new ZodSchemaValidator();
    return {
        /**
         * Validate input data
         */
        validateInput: async (data, options) => {
            if (!schema.input) {
                throw new Error('No input schema defined');
            }
            return validator.validateInput(data, schema.input, options);
        },
        /**
         * Validate config data
         */
        validateConfig: async (data, options) => {
            if (!schema.config) {
                throw new Error('No config schema defined');
            }
            return validator.validateConfig(data, schema.config, options);
        },
        /**
         * Validate complete tool data
         */
        validateToolData: async (data, options) => {
            if (!schema.input || !schema.config) {
                throw new Error('Both input and config schemas must be defined');
            }
            return validator.validateToolSchema(data, {
                input: schema.input,
                config: schema.config,
            }, options);
        },
        /**
         * Generate OpenAPI documentation for the schema
         */
        generateDocumentation: (metadata) => {
            return DocumentationGenerator.generateToolDocumentation(schema, metadata);
        },
        /**
         * Get performance metrics
         */
        getMetrics: () => validator.getMetrics(),
        /**
         * Reset cache and metrics
         */
        reset: () => validator.reset(),
    };
}
// ===== VALIDATION HELPERS =====
/**
 * Quick validation functions for common patterns
 */
const validate = {
    /**
     * Validate an email address
     */
    email: async (value) => {
        return validateField(emailField().required().build(), value, 'email');
    },
    /**
     * Validate a URL
     */
    url: async (value) => {
        return validateField(urlField().required().build(), value, 'url');
    },
    /**
     * Validate a UUID
     */
    uuid: async (value) => {
        return validateField(uuidField().required().build(), value, 'uuid');
    },
    /**
     * Validate an API key
     */
    apiKey: async (value, pattern) => {
        const field = apiKeyField().required();
        if (pattern) {
            field.pattern(pattern);
        }
        return validateField(field.build(), value, 'apiKey');
    },
    /**
     * Validate a positive integer
     */
    positiveInteger: async (value) => {
        return validateField(numberField().required().min(1).integer().build(), value, 'positiveInteger');
    },
    /**
     * Validate a non-empty string
     */
    nonEmptyString: async (value) => {
        return validateField(stringField().required().minLength(1).build(), value, 'nonEmptyString');
    },
    /**
     * Validate an array of strings
     */
    stringArray: async (value, minItems, maxItems) => {
        const field = arrayField(stringField().required().build()).required();
        if (minItems !== undefined)
            field.minItems(minItems);
        if (maxItems !== undefined)
            field.maxItems(maxItems);
        return validateField(field.build(), value, 'stringArray');
    },
};

class ToolUtils {
    /**
     * Creates a successful tool execution result
     */
    static success(data, metadata) {
        return {
            status: 'success',
            data,
            metadata: metadata ? { custom: metadata } : undefined,
        };
    }
    /**
     * Creates an error tool execution result
     */
    static error(message, code = 'TOOL_ERROR', details) {
        return {
            status: 'error',
            error: {
                code,
                message,
                type: 'execution_error',
                details,
            },
        };
    }
    /**
     * Creates an error result from a ToolError instance
     */
    static errorFromException(error) {
        return {
            status: 'error',
            error: {
                code: error.code,
                message: error.message,
                type: 'execution_error',
                details: error.details,
            },
        };
    }
    /**
     * Safely executes a function and returns a tool result
     */
    static async safeExecute(fn) {
        const startTime = Date.now();
        const startedAt = new Date().toISOString();
        try {
            const result = await fn();
            const executionTime = Date.now() - startTime;
            const completedAt = new Date().toISOString();
            return {
                status: 'success',
                data: result,
                timing: {
                    executionTimeMs: executionTime,
                    startedAt,
                    completedAt,
                },
            };
        }
        catch (error) {
            const executionTime = Date.now() - startTime;
            const completedAt = new Date().toISOString();
            if (error instanceof ToolError) {
                return {
                    ...this.errorFromException(error),
                    timing: {
                        executionTimeMs: executionTime,
                        startedAt,
                        completedAt,
                    },
                };
            }
            return {
                status: 'error',
                error: {
                    code: 'UNEXPECTED_ERROR',
                    message: error instanceof Error ? error.message : String(error),
                    type: 'execution_error',
                },
                timing: {
                    executionTimeMs: executionTime,
                    startedAt,
                    completedAt,
                },
            };
        }
    }
    /**
     * Generates a unique execution ID
     */
    static generateExecutionId() {
        const timestamp = Date.now().toString(36);
        const random = Math.random().toString(36).substring(2);
        return `exec_${timestamp}_${random}`;
    }
    /**
     * Validates that a value is not null or undefined
     */
    static required(value, fieldName) {
        if (value === null || value === undefined) {
            throw new Error(`Required field '${fieldName}' is missing`);
        }
        return value;
    }
    /**
     * Deep clones an object
     */
    static deepClone(obj) {
        if (obj === null || typeof obj !== 'object') {
            return obj;
        }
        if (obj instanceof Date) {
            return new Date(obj.getTime());
        }
        if (Array.isArray(obj)) {
            return obj.map(item => this.deepClone(item));
        }
        const cloned = {};
        for (const key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
                cloned[key] = this.deepClone(obj[key]);
            }
        }
        return cloned;
    }
    /**
     * Sanitizes configuration by removing secret fields for logging
     */
    static sanitizeConfig(config, secretFields = []) {
        const sanitized = { ...config };
        // Default secret field patterns
        const defaultSecretPatterns = [
            /api[_-]?key/i,
            /secret/i,
            /token/i,
            /password/i,
            /private[_-]?key/i,
        ];
        for (const key of Object.keys(sanitized)) {
            const isSecret = secretFields.includes(key) ||
                defaultSecretPatterns.some(pattern => pattern.test(key));
            if (isSecret && sanitized[key]) {
                sanitized[key] = '***REDACTED***';
            }
        }
        return sanitized;
    }
    /**
     * Formats error messages for better readability
     */
    static formatErrorMessage(error) {
        if (error instanceof Error) {
            return error.message;
        }
        if (typeof error === 'string') {
            return error;
        }
        try {
            return JSON.stringify(error);
        }
        catch {
            return String(error);
        }
    }
    /**
     * Checks if a URL is valid
     */
    static isValidUrl(url) {
        try {
            new URL(url);
            return true;
        }
        catch {
            return false;
        }
    }
    /**
     * Debounces a function
     */
    static debounce(func, wait) {
        let timeout;
        return (...args) => {
            clearTimeout(timeout);
            timeout = setTimeout(() => func(...args), wait);
        };
    }
    /**
     * Creates a timeout promise that rejects after the specified time
     */
    static timeout(promise, ms) {
        return Promise.race([
            promise,
            new Promise((_, reject) => setTimeout(() => reject(new Error(`Operation timed out after ${ms}ms`)), ms)),
        ]);
    }
    /**
     * Retry function with exponential backoff
     */
    static async retry(fn, options = {}) {
        const { attempts = 3, delay = 1000, backoff = 2, shouldRetry = () => true, } = options;
        let lastError;
        for (let attempt = 1; attempt <= attempts; attempt++) {
            try {
                return await fn();
            }
            catch (error) {
                lastError = error;
                if (attempt === attempts || !shouldRetry(error)) {
                    throw error;
                }
                const waitTime = delay * Math.pow(backoff, attempt - 1);
                await new Promise(resolve => setTimeout(resolve, waitTime));
            }
        }
        throw lastError;
    }
}

/**
 * Core Tool class that manages the complete lifecycle of an AI Spine tool.
 * This class handles HTTP server setup, request processing, validation,
 * execution, monitoring, and security.
 *
 * @example
 * ```typescript
 * import { Tool, stringField, apiKeyField } from '@ai-spine/tools-core';
 *
 * const weatherTool = new Tool({
 *   metadata: {
 *     name: 'weather-tool',
 *     version: '1.0.0',
 *     description: 'Get weather information',
 *     capabilities: ['weather.current']
 *   },
 *   schema: {
 *     input: {
 *       city: stringField().required().minLength(2).build()
 *     },
 *     config: {
 *       apiKey: apiKeyField().required().envVar('WEATHER_API_KEY').build()
 *     }
 *   },
 *   execute: async (input, config, context) => {
 *     // Your tool logic here
 *     return {
 *       status: 'success',
 *       data: { temperature: 22, description: 'sunny' }
 *     };
 *   }
 * });
 *
 * // Start the tool server
 * await weatherTool.start({ port: 3000 });
 * ```
 */
class Tool {
    definition;
    validator;
    app;
    server;
    state = 'stopped';
    config = {};
    toolConfig = null;
    // Metrics and monitoring
    startTime = Date.now();
    executionHistory = [];
    metrics; // Initialized in initializeMetrics()
    eventListeners = {};
    // Security
    validApiKeys = new Set();
    /**
     * Creates a new Tool instance
     *
     * @param definition - Complete tool definition including metadata, schema, and execute function
     *
     * @example
     * ```typescript
     * const tool = new Tool({
     *   metadata: { name: 'my-tool', version: '1.0.0', description: 'A sample tool' },
     *   schema: { input: {}, config: {} },
     *   execute: async (input, config, context) => ({ status: 'success', data: {} })
     * });
     * ```
     */
    constructor(definition) {
        this.definition = definition;
        this.validator = new ZodSchemaValidator();
        this.app = express();
        this.initializeMetrics();
        this.setupExpressApp();
        this.validateDefinition();
    }
    /**
     * Validates the tool definition for completeness and correctness
     * @private
     */
    validateDefinition() {
        if (!this.definition.metadata?.name) {
            throw new ConfigurationError('Tool metadata must include a name');
        }
        if (!this.definition.metadata?.version) {
            throw new ConfigurationError('Tool metadata must include a version');
        }
        if (!this.definition.metadata?.description) {
            throw new ConfigurationError('Tool metadata must include a description');
        }
        if (!this.definition.schema) {
            throw new ConfigurationError('Tool must include a schema definition');
        }
        if (typeof this.definition.execute !== 'function') {
            throw new ConfigurationError('Tool must include an execute function');
        }
    }
    /**
     * Initializes metrics tracking
     * @private
     */
    initializeMetrics() {
        this.metrics = {
            totalExecutions: 0,
            successfulExecutions: 0,
            failedExecutions: 0,
            averageExecutionTimeMs: 0,
            minExecutionTimeMs: Infinity,
            maxExecutionTimeMs: 0,
            errorRatePercent: 0,
            requestsPerMinute: 0,
            memoryUsageBytes: 0,
            cpuUsagePercent: 0,
            uptimeSeconds: 0,
            recentErrors: {},
        };
    }
    /**
     * Sets up the Express.js application with middleware
     * @private
     */
    setupExpressApp() {
        // Security middleware
        this.app.use(helmet({
            contentSecurityPolicy: {
                directives: {
                    defaultSrc: ["'self'"],
                    styleSrc: ["'self'", "'unsafe-inline'"],
                    scriptSrc: ["'self'"],
                    imgSrc: ["'self'", 'data:', 'https:'],
                },
            },
        }));
        // Request parsing middleware
        this.app.use(express.json({ limit: '10mb' }));
        this.app.use(express.urlencoded({ extended: true, limit: '10mb' }));
        // JSON parsing error handling middleware
        this.app.use((error, _req, res, next) => {
            if (error instanceof SyntaxError && 'body' in error) {
                return this.sendStandardError(res, {
                    code: 'INVALID_JSON',
                    message: 'Invalid JSON in request body',
                    type: 'client_error',
                    statusCode: 400,
                    details: {
                        error_message: 'Request body contains malformed JSON',
                        hint: 'Please ensure your JSON is properly formatted',
                    },
                });
            }
            next(error);
        });
        // Request ID middleware
        this.app.use((req, res, next) => {
            req.headers['x-request-id'] = req.headers['x-request-id'] || randomUUID();
            res.setHeader('X-Request-ID', req.headers['x-request-id']);
            next();
        });
        // Request logging middleware (development)
        this.app.use((req, _res, next) => {
            if (this.config.development?.requestLogging) {
                console.log(`[${new Date().toISOString()}] ${req.method} ${req.path} - ${req.ip}`);
            }
            next();
        });
    }
    /**
     * Applies CORS configuration
     * @private
     */
    applyCorsConfiguration() {
        if (this.config.cors) {
            this.app.use(cors({
                origin: this.config.cors.origin || false,
                credentials: this.config.cors.credentials || false,
                allowedHeaders: this.config.cors.allowedHeaders || [
                    'Content-Type',
                    'Authorization',
                    'X-API-Key',
                ],
                methods: this.config.cors.methods || ['GET', 'POST', 'OPTIONS'],
            }));
        }
    }
    /**
     * Applies rate limiting configuration
     * @private
     */
    applyRateLimiting() {
        if (this.config.rateLimit) {
            const limiter = rateLimit({
                windowMs: this.config.rateLimit.windowMs || 15 * 60 * 1000, // 15 minutes
                max: this.config.rateLimit.max || 100,
                message: this.config.rateLimit.message ||
                    'Too many requests, please try again later',
                skipSuccessfulRequests: this.config.rateLimit.skipSuccessfulRequests || false,
                handler: (req, res) => {
                    this.emit('rateLimitExceeded', req.ip || 'unknown', this.config.rateLimit.max);
                    res.status(429).json({
                        error: {
                            code: 'RATE_LIMIT_EXCEEDED',
                            message: this.config.rateLimit.message ||
                                'Too many requests, please try again later',
                            type: 'client_error',
                            retryAfterMs: this.config.rateLimit.windowMs,
                        },
                    });
                },
            });
            this.app.use(limiter);
        }
    }
    /**
     * Sets up authentication middleware
     * @private
     */
    setupAuthentication() {
        if (!this.config.security?.requireAuth) {
            return;
        }
        this.app.use(async (req, res, next) => {
            try {
                // Skip authentication for health, monitoring, and documentation endpoints
                if (req.path === '/health' ||
                    req.path === '/metrics' ||
                    req.path === '/' ||
                    req.path === '/schema') {
                    return next();
                }
                let authenticated = false;
                // Check for API key authentication
                const apiKey = req.headers['x-api-key'] ||
                    req.headers['authorization']?.replace('Bearer ', '');
                if (apiKey && this.validApiKeys.has(apiKey)) {
                    authenticated = true;
                    // Add API key hash to request for logging
                    req.headers['x-api-key-hash'] = createHash('sha256')
                        .update(apiKey)
                        .digest('hex')
                        .substring(0, 8);
                }
                // Check custom authentication
                if (!authenticated && this.config.security?.customAuth) {
                    authenticated = await this.config.security.customAuth(req);
                }
                if (!authenticated) {
                    return res.status(401).json({
                        error: {
                            code: 'AUTHENTICATION_REQUIRED',
                            message: 'Valid API key required',
                            type: 'client_error',
                        },
                    });
                }
                return next();
            }
            catch (error) {
                return res.status(500).json({
                    error: {
                        code: 'AUTHENTICATION_ERROR',
                        message: 'Authentication system error',
                        type: 'server_error',
                    },
                });
            }
        });
    }
    /**
     * Sets up all HTTP endpoints with comprehensive middleware
     * @private
     */
    setupRoutes() {
        // Request logging middleware
        this.app.use((req, _res, next) => {
            if (this.config.development?.requestLogging) {
                const requestId = randomUUID();
                req.headers['x-request-id'] = requestId;
                console.log(`[${new Date().toISOString()}] ${req.method} ${req.path} - Request ID: ${requestId}`);
            }
            next();
        });
        // Request/Response tracking middleware
        this.app.use((req, res, next) => {
            const startTime = performance.now();
            const toolVersion = this.definition.metadata.version;
            const requestLogging = this.config.development?.requestLogging;
            // Add request metadata
            res.locals.requestStart = startTime;
            res.locals.requestId = req.headers['x-request-id'] || randomUUID();
            // Track response
            const originalSend = res.send;
            res.send = function (body) {
                const endTime = performance.now();
                const duration = endTime - startTime;
                // Add response headers
                res.set({
                    'X-Request-ID': res.locals.requestId,
                    'X-Response-Time': `${Math.round(duration)}ms`,
                    'X-Tool-Version': toolVersion,
                });
                if (requestLogging) {
                    console.log(`[${new Date().toISOString()}] ${req.method} ${req.path} - ${res.statusCode} - ${Math.round(duration)}ms`);
                }
                return originalSend.call(this, body);
            };
            next();
        });
        // Content type validation middleware
        this.app.use((req, res, next) => {
            if (req.method === 'POST' && req.path === '/api/execute') {
                if (!req.is('application/json')) {
                    return this.sendStandardError(res, {
                        code: 'INVALID_CONTENT_TYPE',
                        message: 'Content-Type must be application/json',
                        type: 'validation_error',
                        statusCode: 415,
                    }, res.locals.requestId);
                }
            }
            next();
        });
        // POST /api/execute - Main tool execution endpoint
        this.app.post('/api/execute', this.asyncErrorHandler(async (req, res) => {
            await this.handleExecute(req, res);
        }));
        // GET /health - Health check endpoint
        this.app.get('/health', this.asyncErrorHandler(async (req, res) => {
            await this.handleHealth(req, res);
        }));
        // GET /schema - Schema documentation endpoint
        this.app.get('/schema', this.asyncErrorHandler(async (req, res) => {
            await this.handleSchema(req, res);
        }));
        // GET /metrics - Performance metrics endpoint
        this.app.get('/metrics', this.asyncErrorHandler(async (req, res) => {
            await this.handleMetrics(req, res);
        }));
        // GET / - Root endpoint with comprehensive tool information
        this.app.get('/', this.asyncErrorHandler(async (_req, res) => {
            this.updateMetrics(); // Ensure metrics are current
            const toolInfo = {
                name: this.definition.metadata.name,
                version: this.definition.metadata.version,
                description: this.definition.metadata.description,
                capabilities: this.definition.metadata.capabilities || [],
                author: this.definition.metadata.author,
                tags: this.definition.metadata.tags || [],
                status: this.state,
                uptime_seconds: this.metrics.uptimeSeconds,
                health: {
                    status: this.metrics.errorRatePercent > 50
                        ? 'unhealthy'
                        : this.metrics.errorRatePercent > 10
                            ? 'degraded'
                            : 'healthy',
                    error_rate_percent: this.metrics.errorRatePercent,
                    avg_response_time_ms: this.metrics.averageExecutionTimeMs,
                },
                endpoints: {
                    execute: {
                        method: 'POST',
                        path: '/api/execute',
                        description: 'Execute the tool with input data',
                        authentication_required: this.config.security?.requireAuth || false,
                    },
                    health: {
                        method: 'GET',
                        path: '/health',
                        description: 'Get tool health status and metrics',
                    },
                    schema: {
                        method: 'GET',
                        path: '/schema',
                        description: 'Get OpenAPI schema documentation',
                    },
                    metrics: {
                        method: 'GET',
                        path: '/metrics',
                        description: 'Get detailed performance metrics',
                    },
                    info: {
                        method: 'GET',
                        path: '/',
                        description: 'Get basic tool information (this endpoint)',
                    },
                },
                configuration: {
                    rate_limiting: this.config.rateLimit
                        ? {
                            window_ms: this.config.rateLimit.windowMs,
                            max_requests: this.config.rateLimit.max,
                        }
                        : null,
                    cors_enabled: !!this.config.cors,
                    authentication_enabled: this.config.security?.requireAuth || false,
                    monitoring_enabled: this.config.monitoring?.enableMetrics || false,
                },
                runtime_info: {
                    node_version: process.version,
                    platform: process.platform,
                    pid: process.pid,
                    memory_usage_mb: Math.round(this.metrics.memoryUsageBytes / 1024 / 1024),
                },
                timestamp: new Date().toISOString(),
            };
            res.json(toolInfo);
        }));
        // 404 handler for undefined routes
        this.app.use((req, res) => {
            this.sendStandardError(res, {
                code: 'ENDPOINT_NOT_FOUND',
                message: `Endpoint ${req.method} ${req.path} not found`,
                type: 'client_error',
                statusCode: 404,
                details: {
                    available_endpoints: [
                        'POST /api/execute',
                        'GET /health',
                        'GET /schema',
                        'GET /metrics',
                        'GET /',
                    ],
                    method_used: req.method,
                    path_requested: req.path,
                },
            }, res.locals.requestId);
        });
        // Global error handler
        this.app.use((error, _req, res, _next) => {
            this.emit('error', error);
            this.sendStandardError(res, {
                code: 'INTERNAL_SERVER_ERROR',
                message: 'An unexpected error occurred',
                type: 'server_error',
                statusCode: 500,
                details: this.config.development?.verboseErrors
                    ? {
                        error_message: error.message,
                        stack: error.stack,
                    }
                    : undefined,
            }, res.locals.requestId);
        });
    }
    /**
     * Async error handler wrapper for route handlers
     * @private
     */
    asyncErrorHandler(fn) {
        return (req, res, next) => {
            Promise.resolve(fn(req, res, next)).catch(next);
        };
    }
    /**
     * Sends standardized error responses across all endpoints
     *
     * @param res Express response object
     * @param error Error details
     * @param requestId Optional request ID for tracking
     * @private
     */
    sendStandardError(res, error, requestId) {
        const errorResponse = {
            request_id: requestId || res.locals.requestId || randomUUID(),
            status: 'error',
            error: {
                code: error.code,
                message: error.message,
                type: error.type,
                retryable: error.retryable || false,
                retry_after_ms: error.retryAfterMs,
                details: error.details,
            },
            timestamp: new Date().toISOString(),
            tool_info: {
                name: this.definition.metadata.name,
                version: this.definition.metadata.version,
            },
        };
        // Add standard error headers
        res.set({
            'Content-Type': 'application/json',
            'Cache-Control': 'no-cache, no-store, must-revalidate',
            'X-Error-Code': error.code,
            'X-Error-Type': error.type,
        });
        res.status(error.statusCode).json(errorResponse);
    }
    /**
     * Handles the /api/execute endpoint
     * @private
     */
    async handleExecute(req, res) {
        const executionId = randomUUID();
        const startTime = performance.now();
        try {
            // Create execution context
            const context = {
                executionId,
                toolId: this.definition.metadata.name,
                toolVersion: this.definition.metadata.version,
                timestamp: new Date(),
                requestId: req.headers['x-request-id'],
                environment: process.env.NODE_ENV || 'development',
                performance: {
                    startTime,
                    timeoutMs: this.config.timeouts?.execution || 30000,
                },
                security: {
                    apiKeyHash: req.headers['x-api-key-hash'],
                    sourceIp: req.ip,
                    userAgent: req.headers['user-agent'],
                },
            };
            this.emit('beforeExecution', context);
            // Validate request format
            if (!req.body || typeof req.body !== 'object') {
                throw new ValidationError('Request body must be a JSON object');
            }
            const { input_data = {}, config = {} } = req.body;
            // Validate input data
            const inputValidation = await this.validator.validateInput(input_data, this.definition.schema.input);
            if (!inputValidation.success) {
                throw new ValidationError('Input validation failed', inputValidation.errors?.[0]?.path.join('.'), input_data);
            }
            // Use configured tool config if available, otherwise validate provided config
            let validatedConfig;
            if (this.toolConfig) {
                validatedConfig = this.toolConfig;
            }
            else {
                const configValidation = await this.validator.validateConfig(config, this.definition.schema.config);
                if (!configValidation.success) {
                    throw new ConfigurationError('Configuration validation failed', configValidation.errors?.map(e => e.path.join('.')));
                }
                validatedConfig = configValidation.data;
            }
            // Execute the tool
            const result = await this.executeWithTimeout(inputValidation.data, validatedConfig, context);
            const endTime = performance.now();
            const executionTimeMs = endTime - startTime;
            // Record execution statistics
            this.recordExecution({
                executionId,
                startTime,
                endTime,
                durationMs: executionTimeMs,
                success: result.status === 'success',
                errorCode: result.error?.code,
                timestamp: new Date(),
            });
            // Update timing in result
            if (result.timing) {
                result.timing.executionTimeMs = executionTimeMs;
                result.timing.completedAt = new Date().toISOString();
            }
            this.emit('afterExecution', context, result);
            // Send response
            const response = {
                execution_id: executionId,
                status: result.status === 'success' ? 'success' : 'error',
                output_data: result.data,
                error_code: result.error?.code,
                error_message: result.error?.message,
                error_details: result.error?.details,
                execution_time_ms: executionTimeMs,
                timestamp: new Date().toISOString(),
            };
            const statusCode = result.status === 'success'
                ? 200
                : result.error?.type === 'validation_error'
                    ? 400
                    : result.error?.type === 'configuration_error'
                        ? 400
                        : result.error?.type === 'timeout_error'
                            ? 408
                            : 500;
            res.status(statusCode).json(response);
        }
        catch (error) {
            const endTime = performance.now();
            const executionTimeMs = endTime - startTime;
            this.emit('error', error, { executionId });
            // Record failed execution
            this.recordExecution({
                executionId,
                startTime,
                endTime,
                durationMs: executionTimeMs,
                success: false,
                errorCode: error.code || 'UNKNOWN_ERROR',
                timestamp: new Date(),
            });
            let statusCode = 500;
            let errorResponse;
            if (error instanceof ValidationError) {
                statusCode = 400;
                errorResponse = {
                    execution_id: executionId,
                    status: 'error',
                    error_code: error.code,
                    error_message: error.message,
                    error_details: error.details,
                    execution_time_ms: executionTimeMs,
                    timestamp: new Date().toISOString(),
                };
            }
            else if (error instanceof ConfigurationError) {
                statusCode = 400;
                errorResponse = {
                    execution_id: executionId,
                    status: 'error',
                    error_code: error.code,
                    error_message: error.message,
                    error_details: error.details,
                    execution_time_ms: executionTimeMs,
                    timestamp: new Date().toISOString(),
                };
            }
            else {
                errorResponse = {
                    execution_id: executionId,
                    status: 'error',
                    error_code: 'INTERNAL_ERROR',
                    error_message: 'An internal error occurred',
                    error_details: this.config.development?.verboseErrors
                        ? error.message
                        : undefined,
                    execution_time_ms: executionTimeMs,
                    timestamp: new Date().toISOString(),
                };
            }
            res.status(statusCode).json(errorResponse);
        }
    }
    /**
     * Executes the tool with timeout protection
     * @private
     */
    async executeWithTimeout(input, config, context) {
        const timeoutMs = context.performance?.timeoutMs || 30000;
        return new Promise((resolve, reject) => {
            const timeoutId = setTimeout(() => {
                reject(new ExecutionError(`Tool execution timed out after ${timeoutMs}ms`));
            }, timeoutMs);
            (async () => {
                try {
                    const result = await this.definition.execute(input, config, context);
                    clearTimeout(timeoutId);
                    resolve(result);
                }
                catch (error) {
                    clearTimeout(timeoutId);
                    reject(error);
                }
            })();
        });
    }
    /**
     * Handles the /health endpoint with comprehensive health monitoring
     *
     * This endpoint provides detailed health information including:
     * - Overall health status (healthy/degraded/unhealthy)
     * - Performance metrics and thresholds
     * - Custom health checks
     * - Dependency health verification
     * - System resource usage
     *
     * @private
     */
    async handleHealth(_req, res) {
        const healthCheckStart = performance.now();
        try {
            let healthStatus = 'healthy';
            let _details = {};
            const checks = {};
            // Update metrics before health check
            this.updateMetrics();
            // 1. Performance Health Checks
            checks.performance = {
                status: 'healthy',
                metrics: {
                    avg_response_time_ms: this.metrics.averageExecutionTimeMs,
                    error_rate_percent: this.metrics.errorRatePercent,
                    requests_per_minute: this.metrics.requestsPerMinute,
                    memory_usage_mb: Math.round(this.metrics.memoryUsageBytes / 1024 / 1024),
                    uptime_seconds: this.metrics.uptimeSeconds,
                },
            };
            // Check performance thresholds
            if (this.metrics.averageExecutionTimeMs > 5000) {
                checks.performance.status = 'degraded';
                checks.performance.issues = checks.performance.issues || [];
                checks.performance.issues.push('High average response time');
                healthStatus = 'degraded';
            }
            if (this.metrics.errorRatePercent > 50) {
                checks.performance.status = 'unhealthy';
                checks.performance.issues = checks.performance.issues || [];
                checks.performance.issues.push('High error rate');
                healthStatus = 'unhealthy';
            }
            else if (this.metrics.errorRatePercent > 10) {
                checks.performance.status = 'degraded';
                checks.performance.issues = checks.performance.issues || [];
                checks.performance.issues.push('Elevated error rate');
                if (healthStatus === 'healthy')
                    healthStatus = 'degraded';
            }
            // Memory usage check
            const memoryUsageMB = this.metrics.memoryUsageBytes / 1024 / 1024;
            if (memoryUsageMB > 500) {
                checks.performance.status = 'degraded';
                checks.performance.issues = checks.performance.issues || [];
                checks.performance.issues.push('High memory usage');
                if (healthStatus === 'healthy')
                    healthStatus = 'degraded';
            }
            // 2. Tool State Health Check
            checks.tool_state = {
                status: this.state === 'running' ? 'healthy' : 'unhealthy',
                current_state: this.state,
                configuration_valid: !!this.toolConfig,
            };
            if (this.state !== 'running') {
                healthStatus = 'unhealthy';
            }
            // 3. Recent Errors Analysis
            if (Object.keys(this.metrics.recentErrors).length > 0) {
                checks.recent_errors = {
                    status: 'warning',
                    error_types: this.metrics.recentErrors,
                    total_recent_errors: Object.values(this.metrics.recentErrors).reduce((a, b) => a + b, 0),
                };
            }
            // 4. Custom Health Check (if provided)
            if (this.definition.healthCheck) {
                try {
                    const customHealthStart = performance.now();
                    const customHealth = await this.definition.healthCheck();
                    const customHealthDuration = performance.now() - customHealthStart;
                    checks.custom = {
                        status: customHealth.status,
                        details: customHealth.details || {},
                        check_duration_ms: Math.round(customHealthDuration),
                    };
                    // Custom health check overrides if more severe
                    if (customHealth.status === 'unhealthy') {
                        healthStatus = 'unhealthy';
                    }
                    else if (customHealth.status === 'degraded' &&
                        healthStatus === 'healthy') {
                        healthStatus = 'degraded';
                    }
                    _details = { ..._details, ...customHealth.details };
                }
                catch (error) {
                    checks.custom = {
                        status: 'unhealthy',
                        error: 'Custom health check failed',
                        error_message: error.message,
                    };
                    healthStatus = 'unhealthy';
                }
            }
            // 5. System Information
            const systemInfo = {
                node_version: process.version,
                platform: process.platform,
                architecture: process.arch,
                pid: process.pid,
            };
            const healthCheckDuration = performance.now() - healthCheckStart;
            // Build comprehensive health response
            const response = {
                status: healthStatus,
                version: this.definition.metadata.version,
                tool_metadata: {
                    name: this.definition.metadata.name,
                    description: this.definition.metadata.description,
                    version: this.definition.metadata.version,
                    capabilities: this.definition.metadata.capabilities,
                    author: this.definition.metadata.author,
                    tags: this.definition.metadata.tags,
                },
                capabilities: this.definition.metadata.capabilities,
                uptime_seconds: this.metrics.uptimeSeconds,
                last_execution: this.metrics.lastExecutionAt?.toISOString(),
                error_rate_percent: this.metrics.errorRatePercent,
                avg_response_time_ms: this.metrics.averageExecutionTimeMs,
                checks,
                system_info: systemInfo,
                health_check_duration_ms: Math.round(healthCheckDuration),
                timestamp: new Date().toISOString(),
            };
            // Add detailed metrics for degraded/unhealthy status
            if (healthStatus !== 'healthy') {
                response.detailed_metrics = {
                    total_executions: this.metrics.totalExecutions,
                    successful_executions: this.metrics.successfulExecutions,
                    failed_executions: this.metrics.failedExecutions,
                    min_response_time_ms: this.metrics.minExecutionTimeMs,
                    max_response_time_ms: this.metrics.maxExecutionTimeMs,
                    memory_usage_bytes: this.metrics.memoryUsageBytes,
                    recent_errors: this.metrics.recentErrors,
                };
            }
            // Set appropriate HTTP status code
            const statusCode = healthStatus === 'healthy'
                ? 200
                : healthStatus === 'degraded'
                    ? 200
                    : 503;
            // Add custom headers
            res.set({
                'X-Health-Status': healthStatus,
                'X-Tool-Version': this.definition.metadata.version,
                'X-Uptime-Seconds': this.metrics.uptimeSeconds.toString(),
                'Cache-Control': 'no-cache, no-store, must-revalidate',
            });
            res.status(statusCode).json(response);
        }
        catch (error) {
            const healthCheckDuration = performance.now() - healthCheckStart;
            // Emergency health response for critical failures
            const emergencyResponse = {
                status: 'unhealthy',
                version: this.definition.metadata.version,
                tool_metadata: {
                    name: this.definition.metadata.name,
                    version: this.definition.metadata.version,
                },
                capabilities: this.definition.metadata.capabilities,
                uptime_seconds: Math.floor((Date.now() - this.startTime) / 1000),
                error: 'Health check system failure',
                error_message: error.message,
                health_check_duration_ms: Math.round(healthCheckDuration),
                timestamp: new Date().toISOString(),
                checks: {
                    health_system: {
                        status: 'unhealthy',
                        error: 'Health check endpoint failure',
                    },
                },
            };
            res.set({
                'X-Health-Status': 'unhealthy',
                'X-Tool-Version': this.definition.metadata.version,
                'Cache-Control': 'no-cache, no-store, must-revalidate',
            });
            res.status(503).json(emergencyResponse);
        }
    }
    /**
     * Handles the /schema endpoint with comprehensive API documentation
     *
     * This endpoint provides complete OpenAPI 3.0.3 specification including:
     * - Tool metadata and capabilities
     * - Input/config schema definitions
     * - Endpoint documentation with examples
     * - Response schemas and error codes
     * - Integration guides and best practices
     *
     * @private
     */
    async handleSchema(_req, res) {
        const schemaGenerationStart = performance.now();
        try {
            // Generate base OpenAPI documentation
            // TODO: Implement proper documentation generation
            const baseDocumentation = {
                openapi: '3.0.3',
                info: {
                    title: this.definition.metadata.name,
                    version: this.definition.metadata.version,
                    description: this.definition.metadata.description,
                },
                paths: {},
                components: {
                    schemas: {},
                },
            };
            // const baseDocumentation = this.documentationGenerator.generateToolDocumentation(
            //   this.definition.schema,
            //   {
            //     name: this.definition.metadata.name,
            //     description: this.definition.metadata.description,
            //     version: this.definition.metadata.version
            //   }
            // );
            // Enhance with additional tool information
            const enhancedDocumentation = {
                ...baseDocumentation,
                info: {
                    ...baseDocumentation.info,
                    title: `${this.definition.metadata.name} API`,
                    description: `${this.definition.metadata.description}\n\n**Capabilities:** ${this.definition.metadata.capabilities?.join(', ') || 'Not specified'}\n\n**Author:** ${this.definition.metadata.author || 'Not specified'}`,
                    version: this.definition.metadata.version,
                    contact: this.definition.metadata.author
                        ? {
                            name: this.definition.metadata.author,
                        }
                        : undefined,
                    license: this.definition.metadata.license
                        ? {
                            name: this.definition.metadata.license,
                        }
                        : undefined,
                    'x-tool-metadata': this.definition.metadata,
                    'x-runtime-info': {
                        server_version: process.version,
                        uptime_seconds: this.metrics.uptimeSeconds,
                        last_updated: new Date().toISOString(),
                    },
                },
                servers: [
                    {
                        url: `http://localhost:${this.config.port || 3000}`,
                        description: 'Local development server',
                    },
                ],
                paths: {
                    ...baseDocumentation.paths,
                    // Enhanced /api/execute endpoint documentation
                    '/api/execute': {
                        post: {
                            // ...baseDocumentation.paths['/api/execute']?.post, // Commented out - paths is empty
                            summary: 'Execute the AI Spine tool',
                            description: `Execute the ${this.definition.metadata.name} tool with provided input data. This endpoint validates the input against the tool's schema, executes the tool logic, and returns the result.`,
                            operationId: 'executeTool',
                            tags: ['Tool Execution'],
                            security: this.config.security?.requireAuth
                                ? [{ apiKey: [] }]
                                : [],
                            requestBody: {
                                required: true,
                                content: {
                                    'application/json': {
                                        schema: this.generateRequestBodySchema(),
                                    },
                                },
                            },
                            responses: {
                                '200': {
                                    description: 'Tool executed successfully',
                                    headers: {
                                        'X-Execution-ID': {
                                            description: 'Unique execution identifier',
                                            schema: { type: 'string' },
                                        },
                                        'X-Execution-Time-Ms': {
                                            description: 'Execution time in milliseconds',
                                            schema: { type: 'number' },
                                        },
                                    },
                                    content: {
                                        'application/json': {
                                            schema: {
                                                type: 'object',
                                                properties: {
                                                    execution_id: {
                                                        type: 'string',
                                                        description: 'Unique identifier for this execution',
                                                        example: 'exec_1234567890abcdef',
                                                    },
                                                    status: {
                                                        type: 'string',
                                                        enum: ['success'],
                                                        description: 'Execution status',
                                                    },
                                                    output_data: {
                                                        type: 'object',
                                                        description: 'Tool execution results',
                                                    },
                                                    execution_time_ms: {
                                                        type: 'number',
                                                        description: 'Total execution time in milliseconds',
                                                        example: 1250,
                                                    },
                                                    timestamp: {
                                                        type: 'string',
                                                        format: 'date-time',
                                                        description: 'Response timestamp',
                                                    },
                                                },
                                                required: [
                                                    'execution_id',
                                                    'status',
                                                    'execution_time_ms',
                                                    'timestamp',
                                                ],
                                            },
                                        },
                                    },
                                },
                                '400': {
                                    description: 'Invalid input or configuration',
                                    content: {
                                        'application/json': {
                                            schema: {
                                                type: 'object',
                                                properties: {
                                                    execution_id: { type: 'string' },
                                                    status: { type: 'string', enum: ['error'] },
                                                    error_code: {
                                                        type: 'string',
                                                        enum: ['VALIDATION_ERROR', 'CONFIGURATION_ERROR'],
                                                        description: 'Error classification code',
                                                    },
                                                    error_message: {
                                                        type: 'string',
                                                        description: 'Human-readable error description',
                                                    },
                                                    error_details: {
                                                        type: 'array',
                                                        items: { type: 'string' },
                                                        description: 'Detailed validation error messages',
                                                    },
                                                    execution_time_ms: { type: 'number' },
                                                    timestamp: { type: 'string', format: 'date-time' },
                                                },
                                            },
                                        },
                                    },
                                },
                                '401': {
                                    description: 'Authentication required',
                                    content: {
                                        'application/json': {
                                            schema: {
                                                type: 'object',
                                                properties: {
                                                    error: {
                                                        type: 'object',
                                                        properties: {
                                                            code: {
                                                                type: 'string',
                                                                example: 'AUTHENTICATION_REQUIRED',
                                                            },
                                                            message: {
                                                                type: 'string',
                                                                example: 'API key is required',
                                                            },
                                                        },
                                                    },
                                                },
                                            },
                                        },
                                    },
                                },
                                '408': {
                                    description: 'Request timeout',
                                    content: {
                                        'application/json': {
                                            schema: {
                                                type: 'object',
                                                properties: {
                                                    execution_id: { type: 'string' },
                                                    status: { type: 'string', enum: ['error'] },
                                                    error_code: {
                                                        type: 'string',
                                                        example: 'TIMEOUT_ERROR',
                                                    },
                                                    error_message: { type: 'string' },
                                                    execution_time_ms: { type: 'number' },
                                                    timestamp: { type: 'string', format: 'date-time' },
                                                },
                                            },
                                        },
                                    },
                                },
                                '429': {
                                    description: 'Rate limit exceeded',
                                    content: {
                                        'application/json': {
                                            schema: {
                                                type: 'object',
                                                properties: {
                                                    error: {
                                                        type: 'object',
                                                        properties: {
                                                            code: {
                                                                type: 'string',
                                                                example: 'RATE_LIMIT_EXCEEDED',
                                                            },
                                                            message: { type: 'string' },
                                                            retry_after_ms: { type: 'number' },
                                                        },
                                                    },
                                                },
                                            },
                                        },
                                    },
                                },
                                '500': {
                                    description: 'Internal server error',
                                    content: {
                                        'application/json': {
                                            schema: {
                                                type: 'object',
                                                properties: {
                                                    execution_id: { type: 'string' },
                                                    status: { type: 'string', enum: ['error'] },
                                                    error_code: {
                                                        type: 'string',
                                                        example: 'INTERNAL_ERROR',
                                                    },
                                                    error_message: { type: 'string' },
                                                    execution_time_ms: { type: 'number' },
                                                    timestamp: { type: 'string', format: 'date-time' },
                                                },
                                            },
                                        },
                                    },
                                },
                            },
                        },
                    },
                    // Health endpoint documentation
                    '/health': {
                        get: {
                            summary: 'Health check endpoint',
                            description: 'Get comprehensive health status and performance metrics for the tool',
                            operationId: 'getHealth',
                            tags: ['Health & Monitoring'],
                            responses: {
                                '200': {
                                    description: 'Tool is healthy or degraded',
                                    content: {
                                        'application/json': {
                                            schema: {
                                                type: 'object',
                                                properties: {
                                                    status: {
                                                        type: 'string',
                                                        enum: ['healthy', 'degraded'],
                                                        description: 'Overall health status',
                                                    },
                                                    version: { type: 'string' },
                                                    tool_metadata: { type: 'object' },
                                                    capabilities: {
                                                        type: 'array',
                                                        items: { type: 'string' },
                                                    },
                                                    uptime_seconds: { type: 'number' },
                                                    error_rate_percent: { type: 'number' },
                                                    avg_response_time_ms: { type: 'number' },
                                                    checks: { type: 'object' },
                                                    system_info: { type: 'object' },
                                                    health_check_duration_ms: { type: 'number' },
                                                    timestamp: { type: 'string', format: 'date-time' },
                                                },
                                            },
                                        },
                                    },
                                },
                                '503': {
                                    description: 'Tool is unhealthy',
                                    content: {
                                        'application/json': {
                                            schema: {
                                                type: 'object',
                                                properties: {
                                                    status: { type: 'string', enum: ['unhealthy'] },
                                                    error: { type: 'string' },
                                                    version: { type: 'string' },
                                                    uptime_seconds: { type: 'number' },
                                                },
                                            },
                                        },
                                    },
                                },
                            },
                        },
                    },
                    // Metrics endpoint documentation
                    '/metrics': {
                        get: {
                            summary: 'Performance metrics',
                            description: 'Get detailed performance and usage metrics',
                            operationId: 'getMetrics',
                            tags: ['Health & Monitoring'],
                            responses: {
                                '200': {
                                    description: 'Metrics retrieved successfully',
                                    content: {
                                        'application/json': {
                                            schema: {
                                                type: 'object',
                                                properties: {
                                                    totalExecutions: { type: 'number' },
                                                    successfulExecutions: { type: 'number' },
                                                    failedExecutions: { type: 'number' },
                                                    averageExecutionTimeMs: { type: 'number' },
                                                    minExecutionTimeMs: { type: 'number' },
                                                    maxExecutionTimeMs: { type: 'number' },
                                                    errorRatePercent: { type: 'number' },
                                                    requestsPerMinute: { type: 'number' },
                                                    memoryUsageBytes: { type: 'number' },
                                                    uptimeSeconds: { type: 'number' },
                                                    recentErrors: { type: 'object' },
                                                    lastExecutionAt: {
                                                        type: 'string',
                                                        format: 'date-time',
                                                    },
                                                },
                                            },
                                        },
                                    },
                                },
                            },
                        },
                    },
                    // Root endpoint documentation
                    '/': {
                        get: {
                            summary: 'Tool information',
                            description: 'Get basic tool information and available endpoints',
                            operationId: 'getToolInfo',
                            tags: ['Information'],
                            responses: {
                                '200': {
                                    description: 'Tool information retrieved successfully',
                                    content: {
                                        'application/json': {
                                            schema: {
                                                type: 'object',
                                                properties: {
                                                    name: { type: 'string' },
                                                    version: { type: 'string' },
                                                    description: { type: 'string' },
                                                    capabilities: {
                                                        type: 'array',
                                                        items: { type: 'string' },
                                                    },
                                                    status: { type: 'string' },
                                                    endpoints: { type: 'object' },
                                                },
                                            },
                                        },
                                    },
                                },
                            },
                        },
                    },
                },
                // Security schemes
                components: {
                    ...baseDocumentation.components,
                    securitySchemes: {
                        apiKey: {
                            type: 'apiKey',
                            in: 'header',
                            name: 'X-API-Key',
                            description: 'API key for tool authentication. Can also be provided as "Authorization: Bearer <key>"',
                        },
                    },
                    schemas: {
                        ...baseDocumentation.components?.schemas,
                        Error: {
                            type: 'object',
                            properties: {
                                code: { type: 'string', description: 'Error code' },
                                message: { type: 'string', description: 'Error message' },
                                type: { type: 'string', description: 'Error type' },
                                retryable: {
                                    type: 'boolean',
                                    description: 'Whether the error is retryable',
                                },
                                retryAfterMs: {
                                    type: 'number',
                                    description: 'Milliseconds to wait before retry',
                                },
                            },
                        },
                    },
                },
                // Tags for organization
                tags: [
                    {
                        name: 'Tool Execution',
                        description: 'Core tool execution endpoints',
                    },
                    {
                        name: 'Health & Monitoring',
                        description: 'Health checks and performance monitoring',
                    },
                    {
                        name: 'Information',
                        description: 'Tool information and discovery',
                    },
                ],
                // External documentation
                externalDocs: {
                    description: 'AI Spine Tools SDK Documentation',
                    url: 'https://github.com/your-org/ai-spine-tools-sdk',
                },
                // Custom extensions
                'x-tool-config': {
                    authentication_required: this.config.security?.requireAuth || false,
                    rate_limiting: this.config.rateLimit
                        ? {
                            window_ms: this.config.rateLimit.windowMs,
                            max_requests: this.config.rateLimit.max,
                        }
                        : null,
                    cors_enabled: !!this.config.cors,
                    monitoring_enabled: this.config.monitoring?.enableMetrics || false,
                },
                'x-integration-examples': {
                    curl: {
                        basic_execution: `curl -X POST ${this.config.port ? `http://localhost:${this.config.port}` : 'http://localhost:3000'}/api/execute \\
  -H "Content-Type: application/json" \\${this.config.security?.requireAuth
                            ? `
  -H "X-API-Key: your-api-key" \\`
                            : ''}
  -d '${JSON.stringify({
                            input_data: this.generateBasicExampleInput(),
                        }, null, 2).replace(/\n/g, '\n      ')}'`,
                        health_check: `curl ${this.config.port ? `http://localhost:${this.config.port}` : 'http://localhost:3000'}/health`,
                        schema: `curl ${this.config.port ? `http://localhost:${this.config.port}` : 'http://localhost:3000'}/schema`,
                    },
                    javascript: {
                        basic_execution: `const response = await fetch('${this.config.port ? `http://localhost:${this.config.port}` : 'http://localhost:3000'}/api/execute', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',${this.config.security?.requireAuth
                            ? `
    'X-API-Key': 'your-api-key',`
                            : ''}
  },
  body: JSON.stringify({
    input_data: ${JSON.stringify(this.generateBasicExampleInput(), null, 6).replace(/\n/g, '\n    ')}
  })
});

const result = await response.json();
console.log(result);`,
                    },
                    python: {
                        basic_execution: `import requests

response = requests.post('${this.config.port ? `http://localhost:${this.config.port}` : 'http://localhost:3000'}/api/execute', 
    json={
        'input_data': ${JSON.stringify(this.generateBasicExampleInput(), null, 8).replace(/\n/g, '\n        ')}
    },${this.config.security?.requireAuth
                            ? `
    headers={'X-API-Key': 'your-api-key'},`
                            : ''}
)

result = response.json()
print(result)`,
                    },
                },
            };
            const schemaGenerationDuration = performance.now() - schemaGenerationStart;
            // Add generation metadata
            enhancedDocumentation['x-generation-info'] = {
                generated_at: new Date().toISOString(),
                generation_time_ms: Math.round(schemaGenerationDuration),
                sdk_version: '1.0.0',
                tool_state: this.state,
            };
            // Set appropriate headers
            res.set({
                'Content-Type': 'application/json',
                'Cache-Control': 'public, max-age=300', // Cache for 5 minutes
                'X-Schema-Version': this.definition.metadata.version,
                'X-Generation-Time': Math.round(schemaGenerationDuration).toString(),
            });
            res.json(enhancedDocumentation);
        }
        catch (error) {
            const schemaGenerationDuration = performance.now() - schemaGenerationStart;
            // Detailed error response for schema generation failures
            const errorResponse = {
                error: {
                    code: 'SCHEMA_GENERATION_ERROR',
                    message: 'Failed to generate API schema documentation',
                    type: 'server_error',
                    details: {
                        error_message: error.message,
                        generation_time_ms: Math.round(schemaGenerationDuration),
                        timestamp: new Date().toISOString(),
                    },
                },
                fallback_info: {
                    tool_name: this.definition.metadata.name,
                    tool_version: this.definition.metadata.version,
                    available_endpoints: [
                        'POST /api/execute - Execute the tool',
                        'GET /health - Health check',
                        'GET /metrics - Performance metrics',
                        'GET /schema - This endpoint (when working)',
                        'GET / - Basic tool information',
                    ],
                },
            };
            res.status(500).json(errorResponse);
        }
    }
    /**
     * Handles the /metrics endpoint with detailed performance analytics
     *
     * This endpoint provides comprehensive performance metrics including:
     * - Execution statistics and trends
     * - Response time analytics
     * - Error tracking and categorization
     * - Resource usage monitoring
     * - Rate limiting statistics
     *
     * @private
     */
    async handleMetrics(_req, res) {
        const metricsGenerationStart = performance.now();
        try {
            // Update metrics to ensure current data
            this.updateMetrics();
            // Calculate additional analytics
            const now = Date.now();
            const oneHourAgo = now - 60 * 60 * 1000;
            const oneDayAgo = now - 24 * 60 * 60 * 1000;
            const recentExecutions = this.executionHistory.filter(e => now - e.timestamp.getTime() <
                (this.config.monitoring?.metricsRetention || 24 * 60 * 60 * 1000));
            const hourlyExecutions = recentExecutions.filter(e => e.timestamp.getTime() > oneHourAgo);
            const dailyExecutions = recentExecutions.filter(e => e.timestamp.getTime() > oneDayAgo);
            // Calculate success rates by time period
            const hourlySuccessRate = hourlyExecutions.length > 0
                ? (hourlyExecutions.filter(e => e.success).length /
                    hourlyExecutions.length) *
                    100
                : 100;
            const dailySuccessRate = dailyExecutions.length > 0
                ? (dailyExecutions.filter(e => e.success).length /
                    dailyExecutions.length) *
                    100
                : 100;
            // Performance percentiles calculation
            const responseTimes = recentExecutions.map(e => e.durationMs || 0);
            responseTimes.sort((a, b) => a - b);
            const getPercentile = (arr, percentile) => {
                if (arr.length === 0)
                    return 0;
                const index = Math.ceil((percentile / 100) * arr.length) - 1;
                return arr[index] || 0;
            };
            // Enhanced metrics response
            const enhancedMetrics = {
                // Core metrics (existing)
                ...this.metrics,
                // Time-based analytics
                analytics: {
                    success_rates: {
                        overall_percent: 100 - this.metrics.errorRatePercent,
                        last_hour_percent: hourlySuccessRate,
                        last_24h_percent: dailySuccessRate,
                    },
                    execution_counts: {
                        total: this.metrics.totalExecutions,
                        last_hour: hourlyExecutions.length,
                        last_24h: dailyExecutions.length,
                        successful: this.metrics.successfulExecutions,
                        failed: this.metrics.failedExecutions,
                    },
                    response_time_distribution: {
                        p50_ms: getPercentile(responseTimes, 50),
                        p75_ms: getPercentile(responseTimes, 75),
                        p90_ms: getPercentile(responseTimes, 90),
                        p95_ms: getPercentile(responseTimes, 95),
                        p99_ms: getPercentile(responseTimes, 99),
                        min_ms: this.metrics.minExecutionTimeMs,
                        max_ms: this.metrics.maxExecutionTimeMs,
                        avg_ms: this.metrics.averageExecutionTimeMs,
                    },
                    error_breakdown: this.metrics.recentErrors,
                    trend_indicators: {
                        execution_trend: this.calculateTrend(recentExecutions.map(e => ({
                            timestamp: e.timestamp.getTime(),
                            value: 1,
                        }))),
                        response_time_trend: this.calculateTrend(recentExecutions.map(e => ({
                            timestamp: e.timestamp.getTime(),
                            value: e.durationMs || 0,
                        }))),
                        error_rate_trend: this.calculateTrend(recentExecutions.map(e => ({
                            timestamp: e.timestamp.getTime(),
                            value: e.success ? 0 : 1,
                        }))),
                    },
                },
                // System health indicators
                health_indicators: {
                    status: this.metrics.errorRatePercent > 50
                        ? 'critical'
                        : this.metrics.errorRatePercent > 10
                            ? 'warning'
                            : 'healthy',
                    performance_score: this.calculatePerformanceScore(),
                    availability_percent: this.calculateAvailability(),
                    throughput_score: this.calculateThroughputScore(),
                },
                // Resource utilization
                resources: {
                    memory: {
                        used_bytes: this.metrics.memoryUsageBytes,
                        used_mb: Math.round(this.metrics.memoryUsageBytes / 1024 / 1024),
                        heap_info: process.memoryUsage(),
                    },
                    cpu: {
                        usage_percent: this.metrics.cpuUsagePercent || 0,
                    },
                    network: {
                        requests_per_minute: this.metrics.requestsPerMinute,
                        active_connections: this.executionHistory.filter(e => now - e.timestamp.getTime() < 60000 // Last minute
                        ).length,
                    },
                },
                // Tool configuration impact
                configuration_metrics: {
                    rate_limiting: this.config.rateLimit
                        ? {
                            ...this.metrics.rateLimiting,
                            efficiency_percent: this.metrics.rateLimiting
                                ? (this.metrics.rateLimiting.currentWindowRequests /
                                    (this.config.rateLimit.max || 1)) *
                                    100
                                : 0,
                        }
                        : null,
                    authentication_enabled: this.config.security?.requireAuth || false,
                    monitoring_overhead_ms: Math.round(performance.now() - metricsGenerationStart),
                },
                // Metadata
                metrics_metadata: {
                    generated_at: new Date().toISOString(),
                    generation_time_ms: Math.round(performance.now() - metricsGenerationStart),
                    retention_period_ms: this.config.monitoring?.metricsRetention || 24 * 60 * 60 * 1000,
                    data_points_included: recentExecutions.length,
                    uptime_seconds: this.metrics.uptimeSeconds,
                },
            };
            // Set appropriate headers
            res.set({
                'Content-Type': 'application/json',
                'Cache-Control': 'no-cache, no-store, must-revalidate',
                'X-Metrics-Generated': new Date().toISOString(),
                'X-Data-Points': recentExecutions.length.toString(),
            });
            res.json(enhancedMetrics);
        }
        catch (error) {
            const metricsGenerationDuration = performance.now() - metricsGenerationStart;
            this.sendStandardError(res, {
                code: 'METRICS_GENERATION_ERROR',
                message: 'Failed to generate performance metrics',
                type: 'server_error',
                statusCode: 500,
                details: {
                    error_message: error.message,
                    generation_time_ms: Math.round(metricsGenerationDuration),
                    fallback_metrics: {
                        uptime_seconds: this.metrics.uptimeSeconds,
                        total_executions: this.metrics.totalExecutions,
                        error_rate_percent: this.metrics.errorRatePercent,
                    },
                },
            }, res.locals.requestId);
        }
    }
    /**
     * Calculates trend direction for a series of data points
     * @private
     */
    calculateTrend(dataPoints) {
        if (dataPoints.length < 2)
            return 'insufficient_data';
        // Simple linear regression slope calculation
        const n = dataPoints.length;
        const sumX = dataPoints.reduce((sum, point) => sum + point.timestamp, 0);
        const sumY = dataPoints.reduce((sum, point) => sum + point.value, 0);
        const sumXY = dataPoints.reduce((sum, point) => sum + point.timestamp * point.value, 0);
        const sumXX = dataPoints.reduce((sum, point) => sum + point.timestamp * point.timestamp, 0);
        const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
        // Determine trend based on slope
        if (Math.abs(slope) < 0.001)
            return 'stable';
        return slope > 0 ? 'increasing' : 'decreasing';
    }
    /**
     * Calculates overall performance score (0-100)
     * @private
     */
    calculatePerformanceScore() {
        let score = 100;
        // Deduct points for high error rate
        score -= this.metrics.errorRatePercent * 2;
        // Deduct points for slow response times
        if (this.metrics.averageExecutionTimeMs > 1000) {
            score -= Math.min(30, (this.metrics.averageExecutionTimeMs - 1000) / 100);
        }
        // Deduct points for high memory usage
        const memoryUsageMB = this.metrics.memoryUsageBytes / 1024 / 1024;
        if (memoryUsageMB > 100) {
            score -= Math.min(20, (memoryUsageMB - 100) / 20);
        }
        return Math.max(0, Math.round(score));
    }
    /**
     * Calculates availability percentage
     * @private
     */
    calculateAvailability() {
        if (this.metrics.totalExecutions === 0)
            return 100;
        return Math.round(((this.metrics.totalExecutions - this.metrics.failedExecutions) /
            this.metrics.totalExecutions) *
            100);
    }
    /**
     * Calculates throughput score based on requests per minute
     * @private
     */
    calculateThroughputScore() {
        const rpm = this.metrics.requestsPerMinute;
        if (rpm === 0)
            return 0;
        if (rpm >= 60)
            return 100; // Excellent throughput
        if (rpm >= 30)
            return 80; // Good throughput
        if (rpm >= 10)
            return 60; // Fair throughput
        if (rpm >= 1)
            return 40; // Low throughput
        return 20; // Very low throughput
    }
    /**
     * Generates basic example input data for documentation
     * @private
     */
    generateBasicExampleInput() {
        const inputSchema = this.definition.schema.input;
        if (!inputSchema || Object.keys(inputSchema).length === 0) {
            return {};
        }
        const exampleInput = {};
        for (const [key, field] of Object.entries(inputSchema)) {
            if (field.example !== undefined) {
                exampleInput[key] = field.example;
            }
            else {
                // Generate basic example based on field type
                switch (field.type) {
                    case 'string':
                        exampleInput[key] =
                            field.format === 'email'
                                ? 'example@email.com'
                                : field.format === 'url'
                                    ? 'https://example.com'
                                    : 'example';
                        break;
                    case 'number':
                        exampleInput[key] = 42;
                        break;
                    case 'boolean':
                        exampleInput[key] = true;
                        break;
                    case 'array':
                        exampleInput[key] = ['example'];
                        break;
                    case 'object':
                        exampleInput[key] = {};
                        break;
                    case 'enum':
                        // Note: ToolInputField doesn't have values property in current types
                        exampleInput[key] = 'option1';
                        break;
                    default:
                        exampleInput[key] = 'example';
                }
            }
        }
        return exampleInput;
    }
    /**
     * Generates OpenAPI request body schema for the execute endpoint
     * @private
     */
    generateRequestBodySchema() {
        const schema = {
            type: 'object',
            properties: {},
            required: [],
        };
        // Add input_data property if input schema exists
        if (this.definition.schema.input &&
            Object.keys(this.definition.schema.input).length > 0) {
            schema.properties.input_data = {
                type: 'object',
                properties: {},
                required: [],
            };
            // Generate schema for each input field
            for (const [key, field] of Object.entries(this.definition.schema.input)) {
                schema.properties.input_data.properties[key] =
                    DocumentationGenerator.generateOpenAPISchema(field);
                if (field.required) {
                    schema.properties.input_data.required.push(key);
                }
            }
            schema.required.push('input_data');
        }
        // Add config property if config schema exists
        if (this.definition.schema.config &&
            Object.keys(this.definition.schema.config).length > 0) {
            schema.properties.config = {
                type: 'object',
                properties: {},
                required: [],
            };
            // Generate schema for each config field
            for (const [key, field] of Object.entries(this.definition.schema.config)) {
                schema.properties.config.properties[key] =
                    DocumentationGenerator.generateOpenAPISchema(field);
                if (field.required) {
                    schema.properties.config.required.push(key);
                }
            }
        }
        return schema;
    }
    /**
     * Records execution statistics
     * @private
     */
    recordExecution(stats) {
        this.executionHistory.push(stats);
        // Keep only recent executions to prevent memory leak
        const maxHistory = 1000;
        if (this.executionHistory.length > maxHistory) {
            this.executionHistory = this.executionHistory.slice(-maxHistory);
        }
        // Update error counts
        if (!stats.success && stats.errorCode) {
            this.metrics.recentErrors[stats.errorCode] =
                (this.metrics.recentErrors[stats.errorCode] || 0) + 1;
        }
        this.updateMetrics();
    }
    /**
     * Updates calculated metrics
     * @private
     */
    updateMetrics() {
        const now = Date.now();
        const recentExecutions = this.executionHistory.filter(e => now - e.timestamp.getTime() <
            (this.config.monitoring?.metricsRetention || 24 * 60 * 60 * 1000));
        this.metrics.totalExecutions = recentExecutions.length;
        this.metrics.successfulExecutions = recentExecutions.filter(e => e.success).length;
        this.metrics.failedExecutions = recentExecutions.filter(e => !e.success).length;
        if (recentExecutions.length > 0) {
            const durations = recentExecutions.map(e => e.durationMs || 0);
            this.metrics.averageExecutionTimeMs =
                durations.reduce((a, b) => a + b, 0) / durations.length;
            this.metrics.minExecutionTimeMs = Math.min(...durations);
            this.metrics.maxExecutionTimeMs = Math.max(...durations);
            this.metrics.lastExecutionAt = new Date(Math.max(...recentExecutions.map(e => e.timestamp.getTime())));
        }
        this.metrics.errorRatePercent =
            this.metrics.totalExecutions > 0
                ? (this.metrics.failedExecutions / this.metrics.totalExecutions) * 100
                : 0;
        // Calculate requests per minute
        const oneMinuteAgo = now - 60 * 1000;
        const recentMinuteExecutions = recentExecutions.filter(e => e.timestamp.getTime() > oneMinuteAgo);
        this.metrics.requestsPerMinute = recentMinuteExecutions.length;
        this.metrics.uptimeSeconds = Math.floor((now - this.startTime) / 1000);
        // Update memory usage
        const memUsage = process.memoryUsage();
        this.metrics.memoryUsageBytes = memUsage.heapUsed;
        // Clean old error counts
        const oldErrors = Object.keys(this.metrics.recentErrors);
        for (const errorCode of oldErrors) {
            const errorCount = this.metrics.recentErrors[errorCode];
            if (errorCount === 0) {
                delete this.metrics.recentErrors[errorCode];
            }
        }
        // Call custom metrics handler if configured
        if (this.config.monitoring?.customMetrics) {
            this.config.monitoring.customMetrics(this.metrics);
        }
    }
    /**
     * Event emitter functionality
     * @private
     */
    emit(event, ...args) {
        const listener = this.eventListeners[event];
        if (listener) {
            listener(...args);
        }
    }
    /**
     * Sets the tool configuration
     *
     * @param config - Tool configuration object
     *
     * @example
     * ```typescript
     * await tool.setConfig({
     *   apiKey: 'your-api-key-here',
     *   timeout: 30000
     * });
     * ```
     */
    async setConfig(config) {
        const validation = await this.validator.validateConfig(config, this.definition.schema.config);
        if (!validation.success) {
            throw new ConfigurationError('Configuration validation failed', validation.errors?.map(e => e.path.join('.')));
        }
        this.toolConfig = validation.data;
        // Call setup function if provided
        if (this.definition.setup) {
            await this.definition.setup(this.toolConfig);
        }
    }
    /**
     * Adds an event listener
     *
     * @param event - Event name
     * @param listener - Event listener function
     *
     * @example
     * ```typescript
     * tool.on('beforeExecution', (context) => {
     *   console.log(`Executing tool for request ${context.requestId}`);
     * });
     * ```
     */
    on(event, listener) {
        this.eventListeners[event] = listener;
    }
    /**
     * Removes an event listener
     *
     * @param event - Event name
     */
    off(event) {
        delete this.eventListeners[event];
    }
    /**
     * Starts the tool server
     *
     * @param config - Server configuration options
     * @returns Promise that resolves when server is started
     *
     * @example
     * ```typescript
     * await tool.start({
     *   port: 3000,
     *   host: '0.0.0.0',
     *   security: {
     *     apiKeys: ['your-api-key'],
     *     requireAuth: true
     *   }
     * });
     * ```
     */
    async start(config = {}) {
        if (this.state !== 'stopped') {
            throw new Error(`Cannot start tool in state: ${this.state}`);
        }
        this.setState('starting');
        this.config = { ...config };
        // Recreate Express app to ensure clean middleware stack
        this.app = express();
        this.setupExpressApp();
        try {
            // Set up API keys for authentication
            if (this.config.security?.apiKeys) {
                this.validApiKeys = new Set(this.config.security.apiKeys);
            }
            // Set trust proxy if configured
            if (this.config.security?.trustProxy !== undefined) {
                this.app.set('trust proxy', this.config.security.trustProxy);
            }
            // Apply middleware in correct order
            this.applyCorsConfiguration();
            this.applyRateLimiting();
            this.setupAuthentication();
            this.setupRoutes();
            // Start server
            const port = this.config.port !== undefined ? this.config.port : 3000;
            const host = this.config.host || '0.0.0.0';
            await new Promise((resolve, reject) => {
                this.server = this.app.listen(port, host, () => {
                    this.setState('running');
                    this.startTime = Date.now(); // Set actual start time when server is running
                    this.emit('serverStarted', port, host);
                    resolve();
                });
                this.server.on('error', reject);
            });
            console.log(` Tool "${this.definition.metadata.name}" v${this.definition.metadata.version} started on ${host}:${port}`);
        }
        catch (error) {
            this.setState('error');
            throw new ExecutionError(`Failed to start tool server: ${error.message}`, error);
        }
    }
    /**
     * Stops the tool server
     *
     * @returns Promise that resolves when server is stopped
     *
     * @example
     * ```typescript
     * await tool.stop();
     * ```
     */
    async stop() {
        if (this.state !== 'running') {
            throw new Error(`Cannot stop tool in state: ${this.state}`);
        }
        this.setState('stopping');
        try {
            if (this.server) {
                await new Promise((resolve, reject) => {
                    const timeout = this.config.timeouts?.shutdown || 10000;
                    const timeoutId = setTimeout(() => {
                        reject(new Error('Server shutdown timed out'));
                    }, timeout);
                    this.server.close((error) => {
                        clearTimeout(timeoutId);
                        if (error) {
                            reject(error);
                        }
                        else {
                            resolve();
                        }
                    });
                });
            }
            // Call cleanup function if provided
            if (this.definition.cleanup) {
                await this.definition.cleanup();
            }
            this.setState('stopped');
            this.emit('serverStopped');
            console.log(` Tool "${this.definition.metadata.name}" stopped successfully`);
        }
        catch (error) {
            this.setState('error');
            throw new ExecutionError(`Failed to stop tool server: ${error.message}`, error);
        }
    }
    /**
     * Restarts the tool server with optional new configuration
     *
     * @param config - Optional new configuration
     * @returns Promise that resolves when server is restarted
     *
     * @example
     * ```typescript
     * await tool.restart({ port: 3001 });
     * ```
     */
    async restart(config) {
        if (this.state === 'running') {
            await this.stop();
        }
        if (config) {
            this.config = { ...this.config, ...config };
        }
        await this.start(this.config);
    }
    /**
     * Sets the tool state and emits state change event
     * @private
     */
    setState(newState) {
        const oldState = this.state;
        this.state = newState;
        this.emit('stateChange', oldState, newState);
    }
    /**
     * Gets the current tool state
     *
     * @returns Current tool state
     */
    getState() {
        return this.state;
    }
    /**
     * Gets current tool metrics
     *
     * @returns Current metrics object
     */
    getMetrics() {
        this.updateMetrics();
        return { ...this.metrics };
    }
    /**
     * Gets tool metadata
     *
     * @returns Tool metadata object
     */
    getMetadata() {
        return this.definition.metadata;
    }
    /**
     * Gets tool schema
     *
     * @returns Tool schema object
     */
    getSchema() {
        return this.definition.schema;
    }
    /**
     * Tests tool execution with provided input (dry run)
     *
     * @param input - Test input data
     * @param config - Optional configuration (uses set config if not provided)
     * @returns Validation result and execution result if successful
     *
     * @example
     * ```typescript
     * const testResult = await tool.test({
     *   city: 'Madrid',
     *   units: 'metric'
     * });
     *
     * if (testResult.valid) {
     *   console.log('Test execution result:', testResult.result);
     * }
     * ```
     */
    async test(input, config) {
        try {
            // Validate input
            const inputValidation = await this.validator.validateInput(input, this.definition.schema.input);
            if (!inputValidation.success) {
                return {
                    valid: false,
                    errors: inputValidation.errors?.map(e => `${e.path.join('.')}: ${e.message}`),
                };
            }
            // Use provided config or tool config
            let validatedConfig;
            if (config) {
                const configValidation = await this.validator.validateConfig(config, this.definition.schema.config);
                if (!configValidation.success) {
                    return {
                        valid: false,
                        errors: configValidation.errors?.map(e => `config.${e.path.join('.')}: ${e.message}`),
                    };
                }
                validatedConfig = configValidation.data;
            }
            else if (this.toolConfig) {
                validatedConfig = this.toolConfig;
            }
            else {
                return {
                    valid: false,
                    errors: ['No configuration provided and no tool configuration set'],
                };
            }
            // Create test execution context
            const context = {
                executionId: `test-${randomUUID()}`,
                toolId: this.definition.metadata.name,
                toolVersion: this.definition.metadata.version,
                timestamp: new Date(),
                environment: 'test',
                performance: {
                    startTime: performance.now(),
                },
                flags: {
                    dryRun: true,
                },
            };
            // Execute tool
            const result = await this.definition.execute(inputValidation.data, validatedConfig, context);
            return {
                valid: true,
                result,
            };
        }
        catch (error) {
            return {
                valid: false,
                errors: [error.message],
            };
        }
    }
}

export { ConfigurationError, DocumentationGenerator, ExecutionError, SchemaBuilder, SchemaValidator, Tool, ToolError, ToolUtils, ValidationError, ZodSchemaValidator, apiKeyField, arrayField, booleanField, configEnumField, configStringField, createSchema, createValidator, dateField, datetimeField, emailField, enumField, fileField, numberField, objectField, stringField, timeField, urlConfigField, urlField, uuidField, validate, validateField };
//# sourceMappingURL=index.esm.js.map
