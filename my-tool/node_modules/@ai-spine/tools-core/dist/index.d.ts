import { Request } from 'express';

/**
 * Metadata information for a tool that describes its identity, capabilities, and maintenance information.
 * This information is used for tool discovery, documentation generation, and runtime verification.
 *
 * @example
 * ```typescript
 * const metadata: ToolMetadata = {
 *   name: 'weather-api-tool',
 *   version: '1.0.0',
 *   description: 'Fetches current weather data for any city',
 *   capabilities: ['weather.current', 'weather.forecast'],
 *   author: 'John Doe',
 *   license: 'MIT',
 *   homepage: 'https://github.com/user/weather-tool',
 *   repository: 'https://github.com/user/weather-tool.git',
 *   tags: ['weather', 'api', 'external-service'],
 *   requirements: {
 *     apiKeys: ['OPENWEATHER_API_KEY'],
 *     permissions: ['internet-access'],
 *     runtimeDependencies: ['node:18+']
 *   }
 * }
 * ```
 */
interface ToolMetadata {
  /** Unique identifier for the tool (kebab-case recommended) */
  name: string;
  /** Semantic version string (e.g., "1.0.0") */
  version: string;
  /** Human-readable description of what the tool does */
  description: string;
  /** List of specific capabilities this tool provides for AI agents */
  capabilities: string[];
  /** Tool author or maintainer information */
  author?: string;
  /** SPDX license identifier (e.g., "MIT", "Apache-2.0") */
  license?: string;
  /** URL to the tool's homepage or documentation */
  homepage?: string;
  /** Git repository URL for the tool's source code */
  repository?: string;
  /** Tags for categorization and discovery */
  tags?: string[];
  /** Minimum SDK version required to run this tool */
  minSdkVersion?: string;
  /** Tool requirements and dependencies */
  requirements?: {
    /** Required API keys or secrets */
    apiKeys?: string[];
    /** Required system permissions */
    permissions?: string[];
    /** Runtime dependencies (Node.js version, etc.) */
    runtimeDependencies?: string[];
  };
  /** Deprecation information if the tool is being phased out */
  deprecation?: {
    /** Whether the tool is deprecated */
    deprecated: boolean;
    /** Deprecation reason */
    reason?: string;
    /** Alternative tool recommendation */
    alternative?: string;
    /** Date when support will end */
    endOfLife?: string;
  };
}
/**
 * Supported field types for tool input validation.
 * These types map to JSON Schema types and enable automatic validation.
 */
type ToolInputFieldType =
  | 'string'
  | 'number'
  | 'boolean'
  | 'array'
  | 'object'
  | 'date'
  | 'time'
  | 'datetime'
  | 'email'
  | 'url'
  | 'uuid'
  | 'json'
  | 'file'
  | 'enum';
/**
 * String format validation options for string-type fields.
 * These provide additional validation beyond basic string checking.
 */
type StringFormat =
  | 'email'
  | 'url'
  | 'uri'
  | 'uuid'
  | 'regex'
  | 'hostname'
  | 'ipv4'
  | 'ipv6'
  | 'base64'
  | 'jwt'
  | 'slug'
  | 'color-hex'
  | 'semver';
/**
 * Definition of an input field for a tool. This interface describes how to validate
 * and process input data from AI agents, including type checking, constraints, and
 * transformation rules.
 *
 * @example
 * ```typescript
 * const cityField: ToolInputField = {
 *   type: 'string',
 *   required: true,
 *   description: 'Name of the city to get weather for',
 *   minLength: 2,
 *   maxLength: 100,
 *   example: 'Madrid'
 * }
 *
 * const temperatureUnitsField: ToolInputField = {
 *   type: 'enum',
 *   required: false,
 *   description: 'Temperature units for the response',
 *   enum: ['celsius', 'fahrenheit', 'kelvin'],
 *   default: 'celsius'
 * }
 * ```
 */
interface ToolInputField {
  /** The data type of this field */
  type: ToolInputFieldType;
  /** Whether this field is required for tool execution */
  required: boolean;
  /** Human-readable description of what this field represents */
  description?: string;
  /** Default value if not provided (only for non-required fields) */
  default?: any;
  /** Example value for documentation and testing */
  example?: any;
  /** Minimum string length (string type only) */
  minLength?: number;
  /** Maximum string length (string type only) */
  maxLength?: number;
  /** Regex pattern for string validation (string type only) */
  pattern?: string;
  /** String format validation (string type only) */
  format?: StringFormat;
  /** Minimum numeric value (number type only) */
  min?: number;
  /** Maximum numeric value (number type only) */
  max?: number;
  /** Whether the number must be an integer (number type only) */
  integer?: boolean;
  /** Number of decimal places allowed (number type only) */
  precision?: number;
  /** Allowed values for enum type */
  enum?: any[];
  /** Human-readable labels for enum values */
  enumLabels?: string[];
  /** Type definition for array items (array type only) */
  items?: ToolInputField;
  /** Minimum array length (array type only) */
  minItems?: number;
  /** Maximum array length (array type only) */
  maxItems?: number;
  /** Whether array items must be unique (array type only) */
  uniqueItems?: boolean;
  /** Property definitions for object type */
  properties?: Record<string, ToolInputField>;
  /** Names of required properties in objects (object type only) */
  requiredProperties?: string[];
  /** Whether additional properties are allowed in objects (object type only) */
  additionalProperties?: boolean;
  /** Allowed MIME types for file uploads (file type only) */
  allowedMimeTypes?: string[];
  /** Maximum file size in bytes (file type only) */
  maxFileSize?: number;
  /** Minimum date/time value (date/datetime/time types only) */
  minDate?: string;
  /** Maximum date/time value (date/datetime/time types only) */
  maxDate?: string;
  /** Timezone requirement for datetime fields */
  timezone?: 'required' | 'optional' | 'utc-only';
  /** Custom validation function (for complex business logic) */
  customValidator?: string;
  /** Whether this field should be sanitized before validation */
  sanitize?: boolean;
  /** Transformation to apply to the value before validation */
  transform?: 'trim' | 'lowercase' | 'uppercase' | 'normalize';
  /** Whether this field contains sensitive data (affects logging/debugging) */
  sensitive?: boolean;
}
/**
 * Supported field types for tool configuration.
 * Configuration fields are typically set once and used across multiple executions.
 */
type ToolConfigFieldType =
  | 'string'
  | 'number'
  | 'boolean'
  | 'apiKey'
  | 'secret'
  | 'url'
  | 'enum'
  | 'json';
/**
 * Configuration field definition for tools. Configuration fields are typically
 * set during tool setup and remain constant across multiple executions.
 * These differ from input fields as they represent tool-level settings rather
 * than per-execution parameters.
 *
 * @example
 * ```typescript
 * const apiKeyConfig: ToolConfigField = {
 *   type: 'apiKey',
 *   required: true,
 *   description: 'OpenWeatherMap API key for weather data access',
 *   validation: {
 *     pattern: '^[a-f0-9]{32}$',
 *     errorMessage: 'API key must be a 32-character hexadecimal string'
 *   }
 * }
 *
 * const environmentConfig: ToolConfigField = {
 *   type: 'enum',
 *   required: false,
 *   description: 'API environment to use',
 *   enum: ['production', 'staging', 'development'],
 *   default: 'production'
 * }
 * ```
 */
interface ToolConfigField {
  /** The data type of this configuration field */
  type: ToolConfigFieldType;
  /** Whether this configuration field is required for tool operation */
  required: boolean;
  /** Human-readable description of what this configuration represents */
  description?: string;
  /** Default value if not provided (only for non-required fields) */
  default?: any;
  /** Whether this field contains sensitive data (API keys, passwords, etc.) */
  secret?: boolean;
  /** Example value for documentation (should be safe/fake for secret fields) */
  example?: any;
  /** Validation rules for this configuration field */
  validation?: {
    /** Minimum numeric value or string length */
    min?: number;
    /** Maximum numeric value or string length */
    max?: number;
    /** Regex pattern for string validation */
    pattern?: string;
    /** Allowed values for enum type */
    enum?: any[];
    /** Custom error message for validation failures */
    errorMessage?: string;
    /** URL validation for URL type fields */
    allowedProtocols?: string[];
    /** For JSON type, schema to validate against */
    jsonSchema?: any;
  };
  /** Environment variable name where this config can be loaded from */
  envVar?: string;
  /** Whether this field can be overridden at runtime */
  allowRuntimeOverride?: boolean;
  /** Category for grouping related configuration fields */
  category?: string;
  /** Priority level for configuration (higher numbers = more important) */
  priority?: number;
}
/**
 * Complete schema definition for a tool, including input validation rules,
 * configuration requirements, and validation logic. This schema is used to
 * automatically validate requests, generate documentation, and provide
 * type safety throughout the tool execution pipeline.
 *
 * @example
 * ```typescript
 * const weatherToolSchema: ToolSchema = {
 *   input: {
 *     city: {
 *       type: 'string',
 *       required: true,
 *       description: 'Name of the city to get weather for',
 *       minLength: 2,
 *       maxLength: 100,
 *       example: 'Madrid'
 *     },
 *     units: {
 *       type: 'enum',
 *       required: false,
 *       description: 'Temperature units',
 *       enum: ['celsius', 'fahrenheit'],
 *       default: 'celsius'
 *     }
 *   },
 *   config: {
 *     apiKey: {
 *       type: 'apiKey',
 *       required: true,
 *       description: 'OpenWeatherMap API key',
 *       secret: true,
 *       envVar: 'OPENWEATHER_API_KEY'
 *     }
 *   },
 *   validation: {
 *     crossFieldValidation: [
 *       {
 *         rule: 'conditional',
 *         condition: 'input.advanced === true',
 *         requires: ['input.coordinates']
 *       }
 *     ]
 *   }
 * }
 * ```
 */
interface ToolSchema {
  /** Input field definitions - data provided by AI agents for each execution */
  input: Record<string, ToolInputField>;
  /** Configuration field definitions - tool setup and authentication */
  config: Record<string, ToolConfigField>;
  /** Advanced validation rules that span multiple fields */
  validation?: {
    /** Cross-field validation rules */
    crossFieldValidation?: {
      /** Validation rule type */
      rule: 'conditional' | 'mutual_exclusion' | 'dependency' | 'custom';
      /** Human-readable description of the rule */
      description?: string;
      /** Condition that triggers this validation (JavaScript expression) */
      condition?: string;
      /** Fields that are required when condition is true */
      requires?: string[];
      /** Fields that are forbidden when condition is true */
      forbids?: string[];
      /** Custom validation function reference */
      customValidator?: string;
      /** Error message to show when validation fails */
      errorMessage?: string;
    }[];
    /** Global input constraints */
    globalConstraints?: {
      /** Maximum total size of all input data in bytes */
      maxTotalInputSize?: number;
      /** Required input combinations */
      requiredCombinations?: string[][];
      /** Mutually exclusive input groups */
      mutuallyExclusive?: string[][];
    };
  };
  /** Schema version for backward compatibility */
  schemaVersion?: string;
  /** Additional metadata about the schema */
  metadata?: {
    /** When this schema was last updated */
    lastModified?: string;
    /** Author of the schema */
    author?: string;
    /** Tags for schema categorization */
    tags?: string[];
    /** Whether this schema is stable (breaking changes expected) */
    stable?: boolean;
  };
}
interface ToolInput {
  [key: string]: any;
}
interface ToolConfig {
  [key: string]: any;
}
/**
 * Execution context provided to tools during execution. This contains metadata
 * about the current execution, tracking information, and environmental data
 * that tools can use for logging, analytics, and conditional behavior.
 *
 * @example
 * ```typescript
 * const context: ToolExecutionContext = {
 *   executionId: 'exec_1234567890abcdef',
 *   toolId: 'weather-api-tool',
 *   toolVersion: '1.2.0',
 *   timestamp: new Date('2024-01-15T10:30:00Z'),
 *   sessionId: 'session_abc123',
 *   userId: 'user_xyz789',
 *   environment: 'production',
 *   requestId: 'req_fedcba0987654321',
 *   performance: {
 *     startTime: Date.now(),
 *     timeoutMs: 30000
 *   },
 *   security: {
 *     apiKeyHash: 'sha256:abc123...',
 *     permissions: ['weather.read', 'location.read']
 *   }
 * }
 * ```
 */
interface ToolExecutionContext {
  /** Unique identifier for this specific execution */
  executionId: string;
  /** Unique identifier of the tool being executed */
  toolId: string;
  /** Version of the tool being executed */
  toolVersion: string;
  /** Timestamp when execution started */
  timestamp: Date;
  /** Session identifier (groups related executions) */
  sessionId?: string;
  /** User identifier (if available) */
  userId?: string;
  /** Request identifier for tracing across services */
  requestId?: string;
  /** Environment where the tool is running */
  environment?: 'development' | 'staging' | 'production' | string;
  /** Performance and timing information */
  performance?: {
    /** Execution start time (high-resolution timestamp) */
    startTime: number;
    /** Maximum execution time allowed in milliseconds */
    timeoutMs?: number;
    /** Priority level for this execution */
    priority?: 'low' | 'normal' | 'high' | 'critical';
    /** Expected execution duration in milliseconds (for monitoring) */
    expectedDurationMs?: number;
  };
  /** Security and authentication context */
  security?: {
    /** Hash of the API key used (for logging without exposing the key) */
    apiKeyHash?: string;
    /** Permissions granted to this execution */
    permissions?: string[];
    /** Rate limiting information */
    rateLimiting?: {
      /** Remaining requests in current window */
      remaining?: number;
      /** When the rate limit window resets */
      resetAt?: Date;
      /** Total limit per window */
      limit?: number;
    };
    /** Source IP address (if applicable) */
    sourceIp?: string;
    /** User agent string (if applicable) */
    userAgent?: string;
  };
  /** AI agent information */
  agent?: {
    /** Type/name of the AI agent making the request */
    type?: string;
    /** Version of the AI agent */
    version?: string;
    /** Model or engine being used */
    model?: string;
    /** Conversation or thread identifier */
    conversationId?: string;
  };
  /** Debugging and development information */
  debug?: {
    /** Whether debug mode is enabled */
    enabled: boolean;
    /** Debug level */
    level?: 'info' | 'debug' | 'trace';
    /** Custom debug metadata */
    metadata?: Record<string, any>;
  };
  /** Custom metadata for tool-specific context */
  metadata?: Record<string, any>;
  /** Execution flags and options */
  flags?: {
    /** Whether to enable dry-run mode (validation only) */
    dryRun?: boolean;
    /** Whether to bypass caching */
    noCache?: boolean;
    /** Whether to enable verbose output */
    verbose?: boolean;
    /** Custom execution flags */
    custom?: Record<string, boolean>;
  };
}
/**
 * Standardized result format for tool executions. This interface ensures
 * consistent response format across all tools, enabling proper error handling,
 * performance monitoring, and result processing by AI agents.
 *
 * @example
 * ```typescript
 * // Successful execution
 * const successResult: ToolExecutionResult = {
 *   status: 'success',
 *   data: {
 *     temperature: 22,
 *     description: 'sunny',
 *     humidity: 45
 *   },
 *   timing: {
 *     executionTimeMs: 1250,
 *     startedAt: '2024-01-15T10:30:00.000Z',
 *     completedAt: '2024-01-15T10:30:01.250Z'
 *   },
 *   metadata: {
 *     source: 'openweathermap',
 *     cached: false
 *   }
 * }
 *
 * // Error execution
 * const errorResult: ToolExecutionResult = {
 *   status: 'error',
 *   error: {
 *     code: 'API_RATE_LIMIT_EXCEEDED',
 *     message: 'Rate limit exceeded for API key',
 *     type: 'client_error',
 *     retryable: true,
 *     retryAfterMs: 60000
 *   },
 *   timing: {
 *     executionTimeMs: 500,
 *     startedAt: '2024-01-15T10:30:00.000Z',
 *     completedAt: '2024-01-15T10:30:00.500Z'
 *   }
 * }
 * ```
 */
interface ToolExecutionResult {
  /** Execution status - indicates whether the tool executed successfully */
  status: 'success' | 'error' | 'timeout' | 'cancelled';
  /** Result data (only present on successful execution) */
  data?: any;
  /** Error information (only present when status is not 'success') */
  error?: {
    /** Machine-readable error code */
    code: string;
    /** Human-readable error message */
    message: string;
    /** Error type category */
    type:
      | 'validation_error'
      | 'configuration_error'
      | 'execution_error'
      | 'network_error'
      | 'timeout_error'
      | 'system_error'
      | 'client_error'
      | 'server_error';
    /** Additional error details */
    details?: any;
    /** Whether this error can be retried */
    retryable?: boolean;
    /** Suggested retry delay in milliseconds */
    retryAfterMs?: number;
    /** Stack trace (only in development/debug mode) */
    stackTrace?: string;
    /** Related field name (for validation errors) */
    field?: string;
    /** HTTP status code equivalent (if applicable) */
    httpStatusCode?: number;
  };
  /** Timing and performance information */
  timing?: {
    /** Total execution time in milliseconds */
    executionTimeMs: number;
    /** When execution started (ISO 8601 timestamp) */
    startedAt: string;
    /** When execution completed (ISO 8601 timestamp) */
    completedAt: string;
    /** Time spent in different phases */
    phases?: {
      /** Input validation time */
      validationMs?: number;
      /** Core execution time */
      executionMs?: number;
      /** Result serialization time */
      serializationMs?: number;
    };
    /** Whether execution was cancelled due to timeout */
    timedOut?: boolean;
  };
  /** Resource usage information */
  resources?: {
    /** Memory usage at completion (bytes) */
    memoryUsageBytes?: number;
    /** CPU time used (milliseconds) */
    cpuTimeMs?: number;
    /** Network requests made */
    networkRequests?: number;
    /** External API calls made */
    apiCalls?: {
      /** Service name */
      service: string;
      /** Number of calls */
      count: number;
      /** Total time spent */
      totalTimeMs: number;
    }[];
  };
  /** Caching information */
  cache?: {
    /** Whether result was served from cache */
    hit: boolean;
    /** Cache key used */
    key?: string;
    /** When cache entry expires */
    expiresAt?: string;
    /** Cache source */
    source?: 'memory' | 'redis' | 'database' | 'file';
  };
  /** Output metadata and processing information */
  metadata?: {
    /** Data source information */
    source?: string;
    /** Result freshness timestamp */
    freshness?: string;
    /** Result version or revision */
    version?: string;
    /** Whether result has been truncated */
    truncated?: boolean;
    /** Result format and type */
    format?: string;
    /** Data quality indicators */
    quality?: {
      /** Confidence score (0-1) */
      confidence?: number;
      /** Data completeness (0-1) */
      completeness?: number;
      /** Data accuracy indicators */
      accuracy?: number;
    };
    /** Custom tool-specific metadata */
    custom?: Record<string, any>;
  };
  /** Warnings that don't prevent execution but should be noted */
  warnings?: {
    /** Warning code */
    code: string;
    /** Warning message */
    message: string;
    /** Severity level */
    severity: 'low' | 'medium' | 'high';
    /** Additional warning details */
    details?: any;
  }[];
}
interface ToolHealthCheck {
  status: 'healthy' | 'unhealthy' | 'degraded';
  version: string;
  uptime_seconds: number;
  metadata: ToolMetadata;
  capabilities: string[];
  last_execution?: Date;
  error_rate_percent?: number;
  avg_response_time_ms?: number;
}
/**
 * Complete definition of a tool, including all metadata, validation schema,
 * and the execution function. This is the main interface that developers
 * implement when creating tools with the AI Spine SDK.
 *
 * @example
 * ```typescript
 * const weatherTool: ToolDefinition = {
 *   metadata: {
 *     name: 'weather-api-tool',
 *     version: '1.0.0',
 *     description: 'Get current weather for any city',
 *     capabilities: ['weather.current']
 *   },
 *   schema: {
 *     input: {
 *       city: {
 *         type: 'string',
 *         required: true,
 *         description: 'City name'
 *       }
 *     },
 *     config: {
 *       apiKey: {
 *         type: 'apiKey',
 *         required: true,
 *         description: 'Weather API key'
 *       }
 *     }
 *   },
 *   execute: async (input, config, context) => {
 *     // Tool implementation here
 *     return {
 *       status: 'success',
 *       data: { temperature: 22, description: 'sunny' }
 *     };
 *   }
 * }
 * ```
 */
interface ToolDefinition<TInput = ToolInput, TConfig = ToolConfig> {
  /** Tool metadata and identification information */
  metadata: ToolMetadata;
  /** Input and configuration validation schema */
  schema: ToolSchema;
  /** Main tool execution function */
  execute: (
    input: TInput,
    config: TConfig,
    context: ToolExecutionContext
  ) => Promise<ToolExecutionResult>;
  /** Optional setup function called when tool is initialized */
  setup?: (config: TConfig) => Promise<void>;
  /** Optional cleanup function called when tool is stopped */
  cleanup?: () => Promise<void>;
  /** Optional health check function for monitoring */
  healthCheck?: () => Promise<{
    status: 'healthy' | 'unhealthy' | 'degraded';
    details?: Record<string, any>;
  }>;
}
interface AISpineExecuteRequest {
  tool_id: string;
  input_data: ToolInput;
  config?: ToolConfig;
  execution_id?: string;
  metadata?: Record<string, any>;
}
interface AISpineExecuteResponse {
  execution_id: string;
  status: 'success' | 'error';
  output_data?: any;
  error_code?: string;
  error_message?: string;
  error_details?: any;
  execution_time_ms: number;
  timestamp: string;
}
interface AISpineHealthResponse {
  status: 'healthy' | 'unhealthy' | 'degraded';
  version: string;
  tool_metadata: ToolMetadata;
  capabilities: string[];
  uptime_seconds: number;
  last_execution?: string;
  error_rate_percent?: number;
  avg_response_time_ms?: number;
}
declare class ToolError extends Error {
  readonly code: string;
  readonly details?: any;
  constructor(message: string, code?: string, details?: any);
}
declare class ValidationError extends ToolError {
  constructor(message: string, field?: string, value?: any);
}
declare class ConfigurationError extends ToolError {
  constructor(message: string, missingKeys?: string[]);
}
declare class ExecutionError extends ToolError {
  constructor(message: string, cause?: Error);
}
type DeepPartial<T> = {
  [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P];
};
type RequiredFields<T, K extends keyof T> = T & Required<Pick<T, K>>;
type OptionalFields<T, K extends keyof T> = T & Partial<Pick<T, K>>;

/**
 * Advanced validation system for AI Spine tools using Zod for robust schema validation.
 * This module provides comprehensive validation for tool inputs, configurations, and
 * cross-field relationships with performance optimizations and detailed error reporting.
 *
 * @example
 * ```typescript
 * import { ZodSchemaValidator } from '@ai-spine/tools-core';
 *
 * const validator = new ZodSchemaValidator();
 *
 * // Validate tool input
 *
 
 * const result = await validator.validateInput(inputData, inputSchema);
 * if (!result.success) {
 *   console.error('Validation errors:', result.errors);
 * }
 *
 * // Validate configuration
 * const configResult = await validator.validateConfig(config, configSchema);
 * ```
 */

/**
 * Result of a validation operation, providing detailed success/failure information
 */
interface ValidationResult<T = any> {
  /** Whether validation was successful */
  success: boolean;
  /** Validated and transformed data (only present on success) */
  data?: T;
  /** Validation errors (only present on failure) */
  errors?: ValidationErrorDetail[];
  /** Performance information */
  timing?: {
    /** Validation duration in milliseconds */
    durationMs: number;
    /** Whether schema was served from cache */
    fromCache: boolean;
  };
}
/**
 * Detailed validation error information
 */
interface ValidationErrorDetail {
  /** Field path where error occurred */
  path: string[];
  /** Error code for programmatic handling */
  code: string;
  /** Human-readable error message */
  message: string;
  /** Field value that caused the error */
  value?: any;
  /** Expected value or format */
  expected?: string;
  /** Additional error context */
  context?: Record<string, any>;
}
/**
 * Validation options for customizing validation behavior
 */
interface ValidationOptions {
  /** Whether to abort on first error or collect all errors */
  abortEarly?: boolean;
  /** Whether to transform values during validation */
  transform?: boolean;
  /** Whether to strip unknown fields */
  stripUnknown?: boolean;
  /** Custom error messages for specific fields */
  customMessages?: Record<string, string>;
  /** Context for conditional validations */
  context?: Record<string, any>;
}
/**
 * Advanced schema validator using Zod for robust validation with caching,
 * performance optimization, and detailed error reporting.
 */
declare class ZodSchemaValidator {
  private static readonly CACHE_TTL_MS;
  private static readonly MAX_CACHE_SIZE;
  /** Schema cache for performance optimization */
  private readonly schemaCache;
  /** Performance metrics */
  private readonly metrics;
  /**
   * Validates tool input data against the provided schema
   */
  validateInput(
    input: ToolInput,
    schema: Record<string, ToolInputField>,
    _options?: ValidationOptions
  ): Promise<ValidationResult>;
  /**
   * Validates tool configuration against the provided schema
   */
  validateConfig(
    config: ToolConfig,
    schema: Record<string, ToolConfigField>,
    _options?: ValidationOptions
  ): Promise<ValidationResult>;
  /**
   * Validates complete tool schema including cross-field validations
   */
  validateToolSchema(
    data: {
      input: ToolInput;
      config: ToolConfig;
    },
    schema: ToolSchema,
    _options?: ValidationOptions
  ): Promise<ValidationResult>;
  /**
   * Builds a Zod schema from ToolInputField definitions
   */
  private buildInputSchema;
  /**
   * Builds a Zod schema from ToolConfigField definitions
   */
  private buildConfigSchema;
  /**
   * Builds a Zod schema for a single input field
   */
  private buildFieldSchema;
  /**
   * Builds a Zod schema for a single config field
   */
  private buildConfigFieldSchema;
  /**
   * Applies string format validation
   */
  private applyStringFormat;
  /**
   * Applies string transformations
   */
  private applyStringTransform;
  /**
   * Performs the actual validation using Zod
   */
  private performValidation;
  /**
   * Validates cross-field rules
   */
  private validateCrossFieldRules;
  /**
   * Evaluates a single cross-field rule
   */
  private evaluateCrossFieldRule;
  /**
   * Simple condition evaluator (for production, consider using a safer expression evaluator)
   */
  private evaluateCondition;
  /**
   * Gets a nested value from an object using dot notation
   */
  private getNestedValue;
  /**
   * Converts Zod errors to our standardized format
   */
  private convertZodErrors;
  /**
   * Cache management methods
   */
  private generateCacheKey;
  private getFromCache;
  private setCache;
  private cleanupCache;
  private hashObject;
  /**
   * Updates performance metrics
   */
  private updateMetrics;
  /**
   * Gets performance metrics
   */
  getMetrics(): {
    cacheHitRate: number;
    currentCacheSize: number;
    totalValidations: number;
    cacheHits: number;
    averageDurationMs: number;
    totalDurationMs: number;
  };
  /**
   * Clears all caches and resets metrics
   */
  reset(): void;
}
/**
 * Legacy compatibility layer for existing SchemaValidator API
 * @deprecated Use ZodSchemaValidator instead
 */
declare class SchemaValidator {
  private static validator;
  /**
   * @deprecated Use ZodSchemaValidator.validateInput instead
   */
  static validateInput(
    input: ToolInput,
    schema: Record<string, ToolInputField>
  ): Promise<void>;
  /**
   * @deprecated Use ZodSchemaValidator.validateConfig instead
   */
  static validateConfig(
    config: ToolConfig,
    schema: Record<string, ToolConfigField>
  ): Promise<void>;
}

/**
 * Field builder system for creating tool input and configuration schemas.
 * This module provides a fluent API for defining validation rules in a type-safe manner.
 *
 * @example
 * ```typescript
 * import { stringField, numberField, enumField } from '@ai-spine/tools-core';
 *
 * const schema = {
 *   input: {
 *     city: stringField()
 *       .required()
 *       .minLength(2)
 *       .maxLength(100)
 *       .description('Name of the city to get weather for')
 *       .example('Madrid'),
 *
 *     temperature_units: enumField(['celsius', 'fahrenheit', 'kelvin'])
 *       .optional()
 *       .default('celsius')
 *       .description('Temperature units for response'),
 *
 *     max_results: numberField()
 *       .optional()
 *       .min(1)
 *       .max(10)
 *       .integer()
 *       .default(5)
 *   },
 *   config: {
 *     apiKey: apiKeyField()
 *       .required()
 *       .description('OpenWeatherMap API key')
 *       .envVar('OPENWEATHER_API_KEY')
 *   }
 * };
 * ```
 */

/**
 * Base builder class for input fields. Provides common validation methods
 * that are shared across all field types.
 */
declare abstract class BaseInputFieldBuilder<T extends ToolInputField> {
  protected field: Partial<T>;
  /**
   * Mark this field as required for tool execution
   */
  required(): this;
  /**
   * Mark this field as optional (default behavior)
   */
  optional(): this;
  /**
   * Set a human-readable description for this field
   */
  description(desc: string): this;
  /**
   * Set a default value for optional fields
   */
  default(value: any): this;
  /**
   * Set an example value for documentation and testing
   */
  example(value: any): this;
  /**
   * Mark this field as containing sensitive data
   */
  sensitive(): this;
  /**
   * Enable sanitization for this field
   */
  sanitize(): this;
  /**
   * Set transformation to apply before validation
   */
  transform(
    transformation: 'trim' | 'lowercase' | 'uppercase' | 'normalize'
  ): this;
  /**
   * Build the final field definition
   */
  abstract build(): T;
}
/**
 * Builder for string input fields
 */
declare class StringFieldBuilder extends BaseInputFieldBuilder<ToolInputField> {
  constructor();
  /**
   * Set minimum string length
   */
  minLength(length: number): this;
  /**
   * Set maximum string length
   */
  maxLength(length: number): this;
  /**
   * Set regex pattern for validation
   */
  pattern(regex: string): this;
  /**
   * Set string format validation
   */
  format(fmt: StringFormat): this;
  build(): ToolInputField;
}
/**
 * Builder for number input fields
 */
declare class NumberFieldBuilder extends BaseInputFieldBuilder<ToolInputField> {
  constructor();
  /**
   * Set minimum numeric value
   */
  min(value: number): this;
  /**
   * Set maximum numeric value
   */
  max(value: number): this;
  /**
   * Require the number to be an integer
   */
  integer(): this;
  /**
   * Set number of decimal places allowed
   */
  precision(places: number): this;
  build(): ToolInputField;
}
/**
 * Builder for boolean input fields
 */
declare class BooleanFieldBuilder extends BaseInputFieldBuilder<ToolInputField> {
  constructor();
  build(): ToolInputField;
}
/**
 * Builder for enum input fields
 */
declare class EnumFieldBuilder extends BaseInputFieldBuilder<ToolInputField> {
  constructor(values: any[]);
  /**
   * Set human-readable labels for enum values
   */
  labels(labels: string[]): this;
  build(): ToolInputField;
}
/**
 * Builder for array input fields
 */
declare class ArrayFieldBuilder extends BaseInputFieldBuilder<ToolInputField> {
  constructor(itemType: ToolInputField);
  /**
   * Set minimum array length
   */
  minItems(count: number): this;
  /**
   * Set maximum array length
   */
  maxItems(count: number): this;
  /**
   * Require array items to be unique
   */
  unique(): this;
  build(): ToolInputField;
}
/**
 * Builder for object input fields
 */
declare class ObjectFieldBuilder extends BaseInputFieldBuilder<ToolInputField> {
  constructor(properties: Record<string, ToolInputField>);
  /**
   * Set required properties for the object
   */
  requiredProperties(props: string[]): this;
  /**
   * Allow additional properties beyond those defined
   */
  additionalProperties(allowed?: boolean): this;
  build(): ToolInputField;
}
/**
 * Builder for date input fields
 */
declare class DateFieldBuilder extends BaseInputFieldBuilder<ToolInputField> {
  constructor();
  /**
   * Set minimum date value
   */
  minDate(date: string): this;
  /**
   * Set maximum date value
   */
  maxDate(date: string): this;
  build(): ToolInputField;
}
/**
 * Builder for datetime input fields
 */
declare class DateTimeFieldBuilder extends BaseInputFieldBuilder<ToolInputField> {
  constructor();
  /**
   * Set minimum datetime value
   */
  minDate(date: string): this;
  /**
   * Set maximum datetime value
   */
  maxDate(date: string): this;
  /**
   * Set timezone requirement
   */
  timezone(requirement: 'required' | 'optional' | 'utc-only'): this;
  build(): ToolInputField;
}
/**
 * Builder for file input fields
 */
declare class FileFieldBuilder extends BaseInputFieldBuilder<ToolInputField> {
  constructor();
  /**
   * Set allowed MIME types
   */
  mimeTypes(types: string[]): this;
  /**
   * Set maximum file size in bytes
   */
  maxSize(bytes: number): this;
  build(): ToolInputField;
}
/**
 * Base builder for configuration fields
 */
declare abstract class BaseConfigFieldBuilder<T extends ToolConfigField> {
  protected field: Partial<T>;
  /**
   * Mark this configuration field as required
   */
  required(): this;
  /**
   * Mark this configuration field as optional
   */
  optional(): this;
  /**
   * Set description for this configuration field
   */
  description(desc: string): this;
  /**
   * Set default value for optional configuration
   */
  default(value: any): this;
  /**
   * Mark this field as containing sensitive data
   */
  secret(): this;
  /**
   * Set example value for documentation
   */
  example(value: any): this;
  /**
   * Set environment variable name for loading this config
   */
  envVar(name: string): this;
  /**
   * Set category for grouping related configs
   */
  category(cat: string): this;
  /**
   * Allow runtime override of this configuration
   */
  allowRuntimeOverride(): this;
  abstract build(): T;
}
/**
 * Builder for API key configuration fields
 */
declare class ApiKeyFieldBuilder extends BaseConfigFieldBuilder<ToolConfigField> {
  constructor();
  /**
   * Set regex pattern for API key validation
   */
  pattern(regex: string): this;
  /**
   * Set custom error message for validation failures
   */
  errorMessage(message: string): this;
  build(): ToolConfigField;
}
/**
 * Builder for string configuration fields
 */
declare class ConfigStringFieldBuilder extends BaseConfigFieldBuilder<ToolConfigField> {
  constructor();
  /**
   * Set minimum string length
   */
  minLength(length: number): this;
  /**
   * Set maximum string length
   */
  maxLength(length: number): this;
  /**
   * Set regex pattern for validation
   */
  pattern(regex: string): this;
  build(): ToolConfigField;
}
/**
 * Builder for URL configuration fields
 */
declare class UrlConfigFieldBuilder extends BaseConfigFieldBuilder<ToolConfigField> {
  constructor();
  /**
   * Set allowed protocols (e.g., ['https', 'http'])
   */
  protocols(protocols: string[]): this;
  build(): ToolConfigField;
}
/**
 * Builder for enum configuration fields
 */
declare class ConfigEnumFieldBuilder extends BaseConfigFieldBuilder<ToolConfigField> {
  constructor(values: any[]);
  build(): ToolConfigField;
}
/**
 * Create a string input field builder
 */
declare function stringField(): StringFieldBuilder;
/**
 * Create a number input field builder
 */
declare function numberField(): NumberFieldBuilder;
/**
 * Create a boolean input field builder
 */
declare function booleanField(): BooleanFieldBuilder;
/**
 * Create an enum input field builder
 */
declare function enumField(values: any[]): EnumFieldBuilder;
/**
 * Create an array input field builder
 */
declare function arrayField(itemType: ToolInputField): ArrayFieldBuilder;
/**
 * Create an object input field builder
 */
declare function objectField(
  properties: Record<string, ToolInputField>
): ObjectFieldBuilder;
/**
 * Create a date input field builder
 */
declare function dateField(): DateFieldBuilder;
/**
 * Create a datetime input field builder
 */
declare function datetimeField(): DateTimeFieldBuilder;
/**
 * Create a file input field builder
 */
declare function fileField(): FileFieldBuilder;
/**
 * Create an API key configuration field builder
 */
declare function apiKeyField(): ApiKeyFieldBuilder;
/**
 * Create a string configuration field builder
 */
declare function configStringField(): ConfigStringFieldBuilder;
/**
 * Create a URL configuration field builder
 */
declare function urlConfigField(): UrlConfigFieldBuilder;
/**
 * Create an enum configuration field builder
 */
declare function configEnumField(values: any[]): ConfigEnumFieldBuilder;
/**
 * Quick builder for commonly used email fields
 */
declare function emailField(): StringFieldBuilder;
/**
 * Quick builder for commonly used URL fields
 */
declare function urlField(): StringFieldBuilder;
/**
 * Quick builder for UUID fields
 */
declare function uuidField(): StringFieldBuilder;
/**
 * Quick builder for time fields
 */
declare function timeField(): BaseInputFieldBuilder<ToolInputField>;
/**
 * Documentation generator that creates OpenAPI-style documentation from field definitions
 */
declare class DocumentationGenerator {
  /**
   * Generate OpenAPI schema from field definition
   */
  static generateOpenAPISchema(field: ToolInputField | ToolConfigField): any;
  private static mapToOpenAPIType;
  private static addStringProperties;
  private static addNumberProperties;
  private static addArrayProperties;
  private static addObjectProperties;
  private static addEnumProperties;
  private static addDateProperties;
  private static addFileProperties;
  /**
   * Generate complete tool documentation from schema
   */
  static generateToolDocumentation(
    schema: {
      input?: Record<string, ToolInputField>;
      config?: Record<string, ToolConfigField>;
    },
    metadata?: {
      name?: string;
      description?: string;
      version?: string;
    }
  ): any;
}
/**
 * Schema builder class that provides direct validation capabilities
 * along with field building functionality
 */
declare class SchemaBuilder {
  private inputFields;
  private configFields;
  private validator;
  /**
   * Add an input field to the schema
   */
  addInput(name: string, field: ToolInputField): this;
  /**
   * Add a config field to the schema
   */
  addConfig(name: string, field: ToolConfigField): this;
  /**
   * Build the complete schema
   */
  build(): {
    input: {
      [x: string]: ToolInputField;
    };
    config: {
      [x: string]: ToolConfigField;
    };
  };
  /**
   * Validate input data against the current schema
   */
  validateInput(
    data: any,
    options?: ValidationOptions
  ): Promise<ValidationResult>;
  /**
   * Validate config data against the current schema
   */
  validateConfig(
    data: any,
    options?: ValidationOptions
  ): Promise<ValidationResult>;
  /**
   * Validate complete tool data (input + config)
   */
  validateToolData(
    data: {
      input: any;
      config: any;
    },
    options?: ValidationOptions
  ): Promise<ValidationResult>;
  /**
   * Test a single field value against its definition
   */
  testField(
    fieldName: string,
    value: any,
    type?: 'input' | 'config'
  ): Promise<ValidationResult>;
  /**
   * Get performance metrics from the validator
   */
  getMetrics(): {
    cacheHitRate: number;
    currentCacheSize: number;
    totalValidations: number;
    cacheHits: number;
    averageDurationMs: number;
    totalDurationMs: number;
  };
  /**
   * Reset validator cache and metrics
   */
  reset(): void;
  /**
   * Generate OpenAPI documentation for the current schema
   */
  generateDocumentation(metadata?: {
    name?: string;
    description?: string;
    version?: string;
  }): any;
  /**
   * Generate example request data based on the schema
   */
  generateExampleRequest(): {
    input_data?: any;
    config?: any;
  };
  /**
   * Generate an example value for a field
   */
  private generateExampleValue;
}
/**
 * Create a new schema builder instance
 */
declare function createSchema(): SchemaBuilder;
/**
 * Validate a single field value quickly without building a full schema
 */
declare function validateField(
  field: ToolInputField | ToolConfigField,
  value: any,
  fieldName?: string,
  options?: ValidationOptions
): Promise<ValidationResult>;
/**
 * Create a validation function for a specific schema
 */
declare function createValidator(schema: {
  input?: Record<string, ToolInputField>;
  config?: Record<string, ToolConfigField>;
}): {
  /**
   * Validate input data
   */
  validateInput: (
    data: any,
    options?: ValidationOptions
  ) => Promise<ValidationResult<any>>;
  /**
   * Validate config data
   */
  validateConfig: (
    data: any,
    options?: ValidationOptions
  ) => Promise<ValidationResult<any>>;
  /**
   * Validate complete tool data
   */
  validateToolData: (
    data: {
      input: any;
      config: any;
    },
    options?: ValidationOptions
  ) => Promise<ValidationResult<any>>;
  /**
   * Generate OpenAPI documentation for the schema
   */
  generateDocumentation: (metadata?: {
    name?: string;
    description?: string;
    version?: string;
  }) => any;
  /**
   * Get performance metrics
   */
  getMetrics: () => {
    cacheHitRate: number;
    currentCacheSize: number;
    totalValidations: number;
    cacheHits: number;
    averageDurationMs: number;
    totalDurationMs: number;
  };
  /**
   * Reset cache and metrics
   */
  reset: () => void;
};
/**
 * Quick validation functions for common patterns
 */
declare const validate: {
  /**
   * Validate an email address
   */
  email: (value: any) => Promise<ValidationResult>;
  /**
   * Validate a URL
   */
  url: (value: any) => Promise<ValidationResult>;
  /**
   * Validate a UUID
   */
  uuid: (value: any) => Promise<ValidationResult>;
  /**
   * Validate an API key
   */
  apiKey: (value: any, pattern?: string) => Promise<ValidationResult>;
  /**
   * Validate a positive integer
   */
  positiveInteger: (value: any) => Promise<ValidationResult>;
  /**
   * Validate a non-empty string
   */
  nonEmptyString: (value: any) => Promise<ValidationResult>;
  /**
   * Validate an array of strings
   */
  stringArray: (
    value: any,
    minItems?: number,
    maxItems?: number
  ) => Promise<ValidationResult>;
};

declare class ToolUtils {
  /**
   * Creates a successful tool execution result
   */
  static success(
    data: any,
    metadata?: Record<string, any>
  ): ToolExecutionResult;
  /**
   * Creates an error tool execution result
   */
  static error(
    message: string,
    code?: string,
    details?: any
  ): ToolExecutionResult;
  /**
   * Creates an error result from a ToolError instance
   */
  static errorFromException(error: ToolError): ToolExecutionResult;
  /**
   * Safely executes a function and returns a tool result
   */
  static safeExecute<T>(fn: () => Promise<T>): Promise<ToolExecutionResult>;
  /**
   * Generates a unique execution ID
   */
  static generateExecutionId(): string;
  /**
   * Validates that a value is not null or undefined
   */
  static required<T>(value: T | null | undefined, fieldName: string): T;
  /**
   * Deep clones an object
   */
  static deepClone<T>(obj: T): T;
  /**
   * Sanitizes configuration by removing secret fields for logging
   */
  static sanitizeConfig(
    config: Record<string, any>,
    secretFields?: string[]
  ): Record<string, any>;
  /**
   * Formats error messages for better readability
   */
  static formatErrorMessage(error: unknown): string;
  /**
   * Checks if a URL is valid
   */
  static isValidUrl(url: string): boolean;
  /**
   * Debounces a function
   */
  static debounce<T extends (...args: any[]) => any>(
    func: T,
    wait: number
  ): (...args: Parameters<T>) => void;
  /**
   * Creates a timeout promise that rejects after the specified time
   */
  static timeout<T>(promise: Promise<T>, ms: number): Promise<T>;
  /**
   * Retry function with exponential backoff
   */
  static retry<T>(
    fn: () => Promise<T>,
    options?: {
      attempts?: number;
      delay?: number;
      backoff?: number;
      shouldRetry?: (error: any) => boolean;
    }
  ): Promise<T>;
}

/**
 * Configuration options for Tool server setup
 *
 * @example
 * ```typescript
 * const serverConfig: ToolServerConfig = {
 *   port: 3000,
 *   host: '0.0.0.0',
 *   cors: {
 *     origin: ['http://localhost:3000', 'https://myapp.com'],
 *     credentials: true
 *   },
 *   rateLimit: {
 *     windowMs: 15 * 60 * 1000, // 15 minutes
 *     max: 100 // limit each IP to 100 requests per windowMs
 *   },
 *   security: {
 *     apiKeys: ['your-api-key-here'],
 *     requireAuth: true
 *   },
 *   monitoring: {
 *     enableMetrics: true,
 *     metricsRetention: 24 * 60 * 60 * 1000 // 24 hours
 *   }
 * }
 * ```
 */
interface ToolServerConfig {
  /** Port number for the HTTP server */
  port?: number;
  /** Host address to bind to */
  host?: string;
  /** CORS configuration */
  cors?: {
    /** Allowed origins for CORS */
    origin?: string | string[] | boolean;
    /** Whether to allow credentials */
    credentials?: boolean;
    /** Allowed headers */
    allowedHeaders?: string[];
    /** Allowed methods */
    methods?: string[];
  };
  /** Rate limiting configuration */
  rateLimit?: {
    /** Time window in milliseconds */
    windowMs?: number;
    /** Maximum requests per window */
    max?: number;
    /** Custom message for rate limit exceeded */
    message?: string;
    /** Skip successful requests in rate limit count */
    skipSuccessfulRequests?: boolean;
  };
  /** Security configuration */
  security?: {
    /** Valid API keys for authentication */
    apiKeys?: string[];
    /** Whether to require API key authentication */
    requireAuth?: boolean;
    /** Custom authentication function */
    customAuth?: (req: Request) => Promise<boolean>;
    /** Trusted proxy configuration */
    trustProxy?: boolean | number | string;
  };
  /** Monitoring and observability configuration */
  monitoring?: {
    /** Whether to enable performance metrics collection */
    enableMetrics?: boolean;
    /** How long to retain metrics in memory (milliseconds) */
    metricsRetention?: number;
    /** Custom metrics collector */
    customMetrics?: (metrics: ToolMetrics) => void;
  };
  /** Development mode settings */
  development?: {
    /** Enable detailed error messages */
    verboseErrors?: boolean;
    /** Enable hot reload (if supported) */
    hotReload?: boolean;
    /** Enable request/response logging */
    requestLogging?: boolean;
  };
  /** Timeout settings */
  timeouts?: {
    /** Request timeout in milliseconds */
    request?: number;
    /** Tool execution timeout in milliseconds */
    execution?: number;
    /** Server shutdown timeout in milliseconds */
    shutdown?: number;
  };
}
/**
 * Tool execution metrics and performance data
 */
interface ToolMetrics {
  /** Total number of executions */
  totalExecutions: number;
  /** Number of successful executions */
  successfulExecutions: number;
  /** Number of failed executions */
  failedExecutions: number;
  /** Average execution time in milliseconds */
  averageExecutionTimeMs: number;
  /** Minimum execution time in milliseconds */
  minExecutionTimeMs: number;
  /** Maximum execution time in milliseconds */
  maxExecutionTimeMs: number;
  /** Error rate percentage (0-100) */
  errorRatePercent: number;
  /** Requests per minute */
  requestsPerMinute: number;
  /** Current memory usage in bytes */
  memoryUsageBytes: number;
  /** CPU usage percentage (0-100) */
  cpuUsagePercent: number;
  /** Server uptime in seconds */
  uptimeSeconds: number;
  /** Timestamp of last execution */
  lastExecutionAt?: Date;
  /** Recent error codes and their counts */
  recentErrors: Record<string, number>;
  /** Rate limiting statistics */
  rateLimiting?: {
    /** Total requests blocked */
    blockedRequests: number;
    /** Current rate limit status */
    currentWindowRequests: number;
    /** Rate limit window reset time */
    windowResetAt: Date;
  };
}
/**
 * Current tool state
 */
type ToolState =
  | 'stopped'
  | 'starting'
  | 'running'
  | 'stopping'
  | 'error';
/**
 * Events emitted by the Tool instance
 */
interface ToolEvents {
  /** Emitted when tool state changes */
  stateChange: (oldState: ToolState, newState: ToolState) => void;
  /** Emitted before tool execution */
  beforeExecution: (context: ToolExecutionContext) => void;
  /** Emitted after tool execution */
  afterExecution: (
    context: ToolExecutionContext,
    result: ToolExecutionResult
  ) => void;
  /** Emitted when an error occurs */
  error: (error: Error, context?: ToolExecutionContext) => void;
  /** Emitted when server starts */
  serverStarted: (port: number, host: string) => void;
  /** Emitted when server stops */
  serverStopped: () => void;
  /** Emitted for rate limit events */
  rateLimitExceeded: (ip: string, limit: number) => void;
}
/**
 * Core Tool class that manages the complete lifecycle of an AI Spine tool.
 * This class handles HTTP server setup, request processing, validation,
 * execution, monitoring, and security.
 *
 * @example
 * ```typescript
 * import { Tool, stringField, apiKeyField } from '@ai-spine/tools-core';
 *
 * const weatherTool = new Tool({
 *   metadata: {
 *     name: 'weather-tool',
 *     version: '1.0.0',
 *     description: 'Get weather information',
 *     capabilities: ['weather.current']
 *   },
 *   schema: {
 *     input: {
 *       city: stringField().required().minLength(2).build()
 *     },
 *     config: {
 *       apiKey: apiKeyField().required().envVar('WEATHER_API_KEY').build()
 *     }
 *   },
 *   execute: async (input, config, context) => {
 *     // Your tool logic here
 *     return {
 *       status: 'success',
 *       data: { temperature: 22, description: 'sunny' }
 *     };
 *   }
 * });
 *
 * // Start the tool server
 * await weatherTool.start({ port: 3000 });
 * ```
 */
declare class Tool<TInput = ToolInput, TConfig = ToolConfig> {
  private readonly definition;
  private readonly validator;
  private app;
  private server;
  private state;
  private config;
  private toolConfig;
  private startTime;
  private executionHistory;
  private metrics;
  private eventListeners;
  private validApiKeys;
  /**
   * Creates a new Tool instance
   *
   * @param definition - Complete tool definition including metadata, schema, and execute function
   *
   * @example
   * ```typescript
   * const tool = new Tool({
   *   metadata: { name: 'my-tool', version: '1.0.0', description: 'A sample tool' },
   *   schema: { input: {}, config: {} },
   *   execute: async (input, config, context) => ({ status: 'success', data: {} })
   * });
   * ```
   */
  constructor(definition: ToolDefinition<TInput, TConfig>);
  /**
   * Validates the tool definition for completeness and correctness
   * @private
   */
  private validateDefinition;
  /**
   * Initializes metrics tracking
   * @private
   */
  private initializeMetrics;
  /**
   * Sets up the Express.js application with middleware
   * @private
   */
  private setupExpressApp;
  /**
   * Applies CORS configuration
   * @private
   */
  private applyCorsConfiguration;
  /**
   * Applies rate limiting configuration
   * @private
   */
  private applyRateLimiting;
  /**
   * Sets up authentication middleware
   * @private
   */
  private setupAuthentication;
  /**
   * Sets up all HTTP endpoints with comprehensive middleware
   * @private
   */
  private setupRoutes;
  /**
   * Async error handler wrapper for route handlers
   * @private
   */
  private asyncErrorHandler;
  /**
   * Sends standardized error responses across all endpoints
   *
   * @param res Express response object
   * @param error Error details
   * @param requestId Optional request ID for tracking
   * @private
   */
  private sendStandardError;
  /**
   * Handles the /api/execute endpoint
   * @private
   */
  private handleExecute;
  /**
   * Executes the tool with timeout protection
   * @private
   */
  private executeWithTimeout;
  /**
   * Handles the /health endpoint with comprehensive health monitoring
   *
   * This endpoint provides detailed health information including:
   * - Overall health status (healthy/degraded/unhealthy)
   * - Performance metrics and thresholds
   * - Custom health checks
   * - Dependency health verification
   * - System resource usage
   *
   * @private
   */
  private handleHealth;
  /**
   * Handles the /schema endpoint with comprehensive API documentation
   *
   * This endpoint provides complete OpenAPI 3.0.3 specification including:
   * - Tool metadata and capabilities
   * - Input/config schema definitions
   * - Endpoint documentation with examples
   * - Response schemas and error codes
   * - Integration guides and best practices
   *
   * @private
   */
  private handleSchema;
  /**
   * Handles the /metrics endpoint with detailed performance analytics
   *
   * This endpoint provides comprehensive performance metrics including:
   * - Execution statistics and trends
   * - Response time analytics
   * - Error tracking and categorization
   * - Resource usage monitoring
   * - Rate limiting statistics
   *
   * @private
   */
  private handleMetrics;
  /**
   * Calculates trend direction for a series of data points
   * @private
   */
  private calculateTrend;
  /**
   * Calculates overall performance score (0-100)
   * @private
   */
  private calculatePerformanceScore;
  /**
   * Calculates availability percentage
   * @private
   */
  private calculateAvailability;
  /**
   * Calculates throughput score based on requests per minute
   * @private
   */
  private calculateThroughputScore;
  /**
   * Generates basic example input data for documentation
   * @private
   */
  private generateBasicExampleInput;
  /**
   * Generates OpenAPI request body schema for the execute endpoint
   * @private
   */
  private generateRequestBodySchema;
  /**
   * Records execution statistics
   * @private
   */
  private recordExecution;
  /**
   * Updates calculated metrics
   * @private
   */
  private updateMetrics;
  /**
   * Event emitter functionality
   * @private
   */
  private emit;
  /**
   * Sets the tool configuration
   *
   * @param config - Tool configuration object
   *
   * @example
   * ```typescript
   * await tool.setConfig({
   *   apiKey: 'your-api-key-here',
   *   timeout: 30000
   * });
   * ```
   */
  setConfig(config: TConfig): Promise<void>;
  /**
   * Adds an event listener
   *
   * @param event - Event name
   * @param listener - Event listener function
   *
   * @example
   * ```typescript
   * tool.on('beforeExecution', (context) => {
   *   console.log(`Executing tool for request ${context.requestId}`);
   * });
   * ```
   */
  on<K extends keyof ToolEvents>(event: K, listener: ToolEvents[K]): void;
  /**
   * Removes an event listener
   *
   * @param event - Event name
   */
  off<K extends keyof ToolEvents>(event: K): void;
  /**
   * Starts the tool server
   *
   * @param config - Server configuration options
   * @returns Promise that resolves when server is started
   *
   * @example
   * ```typescript
   * await tool.start({
   *   port: 3000,
   *   host: '0.0.0.0',
   *   security: {
   *     apiKeys: ['your-api-key'],
   *     requireAuth: true
   *   }
   * });
   * ```
   */
  start(config?: ToolServerConfig): Promise<void>;
  /**
   * Stops the tool server
   *
   * @returns Promise that resolves when server is stopped
   *
   * @example
   * ```typescript
   * await tool.stop();
   * ```
   */
  stop(): Promise<void>;
  /**
   * Restarts the tool server with optional new configuration
   *
   * @param config - Optional new configuration
   * @returns Promise that resolves when server is restarted
   *
   * @example
   * ```typescript
   * await tool.restart({ port: 3001 });
   * ```
   */
  restart(config?: ToolServerConfig): Promise<void>;
  /**
   * Sets the tool state and emits state change event
   * @private
   */
  private setState;
  /**
   * Gets the current tool state
   *
   * @returns Current tool state
   */
  getState(): ToolState;
  /**
   * Gets current tool metrics
   *
   * @returns Current metrics object
   */
  getMetrics(): ToolMetrics;
  /**
   * Gets tool metadata
   *
   * @returns Tool metadata object
   */
  getMetadata(): ToolMetadata;
  /**
   * Gets tool schema
   *
   * @returns Tool schema object
   */
  getSchema(): ToolSchema;
  /**
   * Tests tool execution with provided input (dry run)
   *
   * @param input - Test input data
   * @param config - Optional configuration (uses set config if not provided)
   * @returns Validation result and execution result if successful
   *
   * @example
   * ```typescript
   * const testResult = await tool.test({
   *   city: 'Madrid',
   *   units: 'metric'
   * });
   *
   * if (testResult.valid) {
   *   console.log('Test execution result:', testResult.result);
   * }
   * ```
   */
  test(
    input: TInput,
    config?: TConfig
  ): Promise<{
    valid: boolean;
    errors?: string[];
    result?: ToolExecutionResult;
  }>;
}

export { ConfigurationError, DocumentationGenerator, ExecutionError, SchemaBuilder, SchemaValidator, Tool, ToolError, ToolUtils, ValidationError, ZodSchemaValidator, apiKeyField, arrayField, booleanField, configEnumField, configStringField, createSchema, createValidator, dateField, datetimeField, emailField, enumField, fileField, numberField, objectField, stringField, timeField, urlConfigField, urlField, uuidField, validate, validateField };
export type { AISpineExecuteRequest, AISpineExecuteResponse, AISpineHealthResponse, DeepPartial, OptionalFields, RequiredFields, StringFormat, ToolConfig, ToolConfigField, ToolConfigFieldType, ToolDefinition, ToolEvents, ToolExecutionContext, ToolExecutionResult, ToolHealthCheck, ToolInput, ToolInputField, ToolInputFieldType, ToolMetadata, ToolMetrics, ToolSchema, ToolServerConfig, ToolState, ValidationErrorDetail, ValidationOptions, ValidationResult };
